//! Заняття 1. Вступ до Node.js
// Що таке Node.js

// Node.js — це середовище виконання JavaScript поза браузером.

// У браузері JavaScript керує DOM і роботою інтерфейсу.Node.js же дозволяє запускати цей код на комп’ютері чи сервері, відкриваючи
// шлях до створення бекенд - застосунків.

// Його основа — движок V8 (той самий, що використовується у Google Chrome). Саме завдяки цьому Node.js швидкий і ефективний.

// Де використовується Node.js

// Node.js часто застосовують для:

// Веб-серверів і API — щоб фронтенд отримував дані з бекенду.
// Чатів та інших real-time застосунків — де важлива миттєва реакція (наприклад, повідомлення без перезавантаження сторінки).
// Прототипів і невеликих проєктів — коли треба швидко зробити робочий бекенд.
// Інструментів для фронтенду — більшість сучасних збирачів (webpack, vite) працюють на Node.js.

// Ключова перевага для вас як початківців: ви вже знаєте JavaScript з фронтенду → з Node.js можна використовувати ті самі знання
// для створення бекенду.

// Як працює Node.js

// Node.js побудований на принципі асинхронного вводу/виводу (non-blocking I/O).

// Це означає, що він може обробляти сотні й тисячі запитів одночасно, не блокуючись на одному з них.

// Приклад: коли сервер читає файл з диска, він делегує цю операцію файловій системі і в цей час може обробляти інші запити.

// Завдяки цьому Node.js дуже ефективний для додатків, які потребують великої кількості одночасних підключень (чати, API, стрімінги).

// Переваги Node.js

// Асинхронність
// Не блокує виконання, поки чекає результат від бази даних чи файлової системи.
// Одна мова на фронті та бекенді
// Той самий JavaScript можна використовувати і для клієнтської частини, і для серверної.Це зручно для команд і дозволяє швидше
// розробляти проєкти.
// Кросплатформеність
// Node.js працює на Windows, Linux, macOS і навіть вбудованих системах.
// Швидкість
// Написаний на C++ і працює на V8. Дозволяє створювати розширення (N-API) і підтримує багатопоточність у внутрішніх операціях.

// Обмеження Node.js

// Node.js не підходить для задач із великим навантаженням на процесор:

// складні математичні обчислення,
// рендеринг зображень,
// обробка відео чи аудіо “всередині” сервера.
// Тут краще використовувати інші мови (C++, Go, Rust).

//!    Ініціалізація Node.js-проєкта

// Для створення проєкта необхідно переконатися, що на вашому комп’ютері встановлено Node.js.Для цього введіть у терміналі
// команду для перевірки його версії:

// node --version

// Якщо у терміналі ви побачите щось на кшталт v18.17.0(або новішу версію), значить Node.js уже встановлено.Якщо ж отримаєте
// відповідь command not found: node, тоді потрібно завантажити та встановити LTS - версію з офіційного сайту.

// Для роботи з Node.js-застосунками використовується npm — менеджер пакетів.

// У терміналі створіть папку проєкта з будь-якою назвою:

// mkdir nodejs-app

// Перейдіть у створену папку:

// cd nodejs-app

// Ініціалізуйте npm:

// npm init -y

// Дивись відео в папкі Node за такою назвою:

// 1. Модуль 1. Основи Node.js - Ініціалізація Node.js-проєкта

// З’явиться файл package.json із базовою інформацією про проєкт.Додамо сучасний режим ESM(щоб можна було використовувати
//   import/export), додавши властивість "type": "module".

// {
//   "name": "nodejs-app",
//   "version": "1.0.0",
//   "description": "",
//   "main": "src/index.js",
//   // Додали нову властивість type
//   "type":"module",
//   "scripts": {
//     "test": "echo \\"Error: no test specified\\" && exit 1"
//   },
//   "keywords": [],
//   "author": "",
//   "license": "ISC"
// }

//!   Виконання JS поза браузером

// Створимо папку src, де зберігатиметься весь код, і додамо у ній перший файл index.js з таким вмістом:

// // src/index.js

// const message = 'Hello world';

// console.log(message);

// JavaScript-код можна виконати за допомогою команди node, вказавши після неї шлях до файлу, який потрібно запустити:

// node src/index.js

// У терміналі побачимо результат:

// Hello world
// Дивсь відео в папкі Node-Відео до конспекту за такою назвою:

// 2. Модуль 1. Основи Node.js - Виконання JS поза браузером-1

// Nodemon

// Незручно щоразу після змін у коді вручну запускати JavaScript - файл або сервер, щоб перевірити результат.Щоб автоматизувати
// цей процес, використаємо пакет nodemon, який автоматично перезапускає застосунок після змін у файлах.

// Встановіть його як залежність для розробки командою:

// npm install -D nodemon

// Додайте скрипт у файл package.json:

// // package.json

// {
//   "scripts": {
//     "dev": "nodemon src/index.js"
//   }
// }

// Тепер ви можете запускати застосунок за допомогою команди:

// npm run dev

// При збереженні змін у JavaScript-файлах він буде автоматично перезапускатися.
// Дивсь відео в папкі Node-Відео до конспекту за такою назвою:

// 3. Модуль 1. Основи Node.js - Виконання JS поза браузером-2

//!  Налаштування робочого середовища

// Додайте в кореневу папку проєкта конфігураційні файли та встановіть відповідні розширення для VSCode.

// EditorConfig

// Встановіть розширення EditorConfig та створіть файл.editorconfig.Він забезпечує однакові відступи, кодування й кінцівки
// рядків у різних редакторах.Такі налаштування допомагають уникнути проблем, пов’язаних із різницею символів кінця рядка між
// різними операційними системами.

// root = true

// [*]
// charset = utf-8
// end_of_line = lf
// insert_final_newline = true
// indent_style = space
// indent_size = 2
// trim_trailing_whitespace = true

// //? Prettier

// Встановіть розширення Prettier та додайте файл .prettierrc, у якому зберігатимуться налаштування для форматування коду.

// {
//   "semi": true,
//   "singleQuote": true,
//   "trailingComma": "all",
//   "printWidth": 80,
//   "tabWidth": 2,
//   "useTabs": false,
//   "arrowParens": "always",
//   "bracketSpacing": true,
//   "endOfLine": "lf"
// }

// //?  ESLint

// Лінтинг коду відповідно до стандарту — важлива складова кожного проєкта. Він дозволяє задати єдиний стиль написання коду для всієї команди та контролювати дотримання певних кращих практик.

// Для роботи з ESLint у VS Code потрібно встановити розширення ESLint.

// У наступному відео розглянемо етапи ініціалізації ESLint у проєкті командою:

// Подивсь відео в папкі Node - Відео до конспекту за такою назвою:
// "4. Модуль 1. Основи Node.js - Налаштування робочого середовища"

// npm init @eslint/config@latest

// Замініть вміст свого файлу eslint.config.mjs наступним кодом. Ми трохи його доповнили під наші потреби, додавши властивість rules.

// import js from "@eslint/js";
// import globals from "globals";
// import { defineConfig } from "eslint/config";

// export default defineConfig([
//   {
//     files: ["**/*.{js,mjs,cjs}"],
//     plugins: { js },
//     extends: ["js/recommended"],
//     languageOptions: { globals: globals.node },
//     rules: {
//       semi: "error",
//       "no-unused-vars": ["error", { args: "none" }],
//       "no-undef": "error",
//     },
//   },
// ]);

// //?  GitIgnore

// Файл .gitignore використовується для вказання файлів і папок, які не повинні потрапляти в репозиторій Git.

// .vscode
// .DS_Store
// .idea

// # Logs
// logs
// *.log
// npm-debug.log*
// yarn-debug.log*
// yarn-error.log*
// lerna-debug.log*

// # Diagnostic reports (https://nodejs.org/api/report.html)
// report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

// # Runtime data
// pids
// *.pid
// *.seed
// *.pid.lock

// # Directory for instrumented libs generated by jscoverage/JSCover
// lib-cov

// # Coverage directory used by tools like istanbul
// coverage
// *.lcov

// # nyc test coverage
// .nyc_output

// # Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
// .grunt

// # Bower dependency directory (https://bower.io/)
// bower_components

// # node-waf configuration
// .lock-wscript

// # Compiled binary addons (https://nodejs.org/api/addons.html)
// build/Release

// # Dependency directories
// node_modules/
// jspm_packages/

// # Snowpack dependency directory (https://snowpack.dev/)
// web_modules/

// # TypeScript cache
// *.tsbuildinfo

// # Optional npm cache directory
// .npm

// # Optional eslint cache
// .eslintcache

// # Optional stylelint cache
// .stylelintcache

// # Optional REPL history
// .node_repl_history

// # Output of 'npm pack'
// *.tgz

// # Yarn Integrity file
// .yarn-integrity

// # dotenv environment variable files
// .env
// .env.*
// !.env.example

// # parcel-bundler cache (https://parceljs.org/)
// .cache
// .parcel-cache

// # Next.js build output
// .next
// out

// # Nuxt.js build / generate output
// .nuxt
// dist

// # Gatsby files
// .cache/
// # Comment in the public line in if your project uses Gatsby and not Next.js
// # https://nextjs.org/blog/next-9-1#public-directory-support
// # public

// # vuepress build output
// .vuepress/dist

// # vuepress v2.x temp and cache directory
// .temp
// .cache

// # Sveltekit cache directory
// .svelte-kit/

// # vitepress build output
// **/.vitepress/dist

// # vitepress cache directory
// **/.vitepress/cache

// # Docusaurus cache and generated files
// .docusaurus

// # Serverless directories
// .serverless/

// # FuseBox cache
// .fusebox/

// # DynamoDB Local files
// .dynamodb/

// # Firebase cache directory
// .firebase/

// # TernJS port file
// .tern-port

// # Stores VSCode versions used for testing VSCode extensions
// .vscode-test

// # yarn v3
// .pnp.*
// .yarn/*
// !.yarn/patches
// !.yarn/plugins
// !.yarn/releases
// !.yarn/sdks
// !.yarn/versions

// # Vite logs files
// vite.config.js.timestamp-*
// vite.config.ts.timestamp-*

//!   Вбудовані модулі Node.js

// У Node.js є набір вбудованих модулів, які доступні відразу без встановлення додаткових пакетів. Наприклад:

// node:os — інформація про операційну систему;
// node:http — створення веб-серверів;
// node:path — робота зі шляхами до файлів і папок;
// node:fs — робота з файловою системою.

// У цьому розділі ми базово розглянемо роботу з файловою системою та формування шляхів.

// Модуль path

// Модуль node:path допомагає працювати з файловими шляхами у різних операційних системах.

// У Windows для побудови шляхів використовується роздільник \\, а у POSIX-системах (Linux, macOS) — /.

// Щоб уникнути проблем із цими відмінностями, у Node.js варто використовувати методи модуля path, а не писати шляхи вручну.

// Важливо! Модуль path не перевіряє, чи існує файл або папка. Він тільки допомагає правильно формувати шляхи.

// path.join(...paths)

// Об’єднує частини шляху у правильний формат для поточної ОС.

// import path from "node:path";

// const somePath = path.join("some_folder", "some_file.txt");
// // на macOS → 'some_folder/some_file.txt'
// // на Windows → 'some_folder\\\\some_file.txt'

// Можна вкладати виклики, щоб будувати складніші шляхи:

// import path from "node:path";

// // абсолютний шлях до робочої директорії
// const pathToWorkDir = path.join(process.cwd());

// // додаємо нові частини до шляху
// const pathToFile = path.join(pathToWorkDir, "some_folder", "some_file.txt");

// // macOS → /коренева_папка/some_folder/some_file.txt
// // Windows → C:\\\\коренева_папка\\\\some_folder\\\\some_file.txt

// Тут ми використали глобальну змінну process, а метод process.cwd() повертає абсолютний шлях до папки, з якої запущений процес Node.js.

// path.parse(path)

// Розбирає рядок-шлях на складові частини:

// import path from "node:path";

// // macOS
// console.log(path.parse("/home/user/dir/file.txt"));
// /*
// {
//   root: '/',
//   dir: '/home/user/dir',
//   base: 'file.txt',
//   ext: '.txt',
//   name: 'file'
// }
// */

// // Windows
// console.log(path.parse("C:\\\\path\\\\dir\\\\file.txt"));
// /*
// {
//   root: 'C:\\\\',
//   dir: 'C:\\\\path\\\\dir',
//   base: 'file.txt',
//   ext: '.txt',
//   name: 'file'
// }
// */

// За потреби більше методів можна знайти у документації Node.js, але основні, які нам потрібні, ми вже розглянули.

// Модуль fs

// Одна з головних можливостей Node.js — робота з файлами та папками. Для цього використовується вбудований модуль fs.

// Багато його методів існують у двох варіантах:

// синхронні (readFileSync, writeFileSync), які блокують виконання коду;
// асинхронні (через fs/promises), які працюють із Promise і не блокують.

// Синхронні методи іноді зручно застосувати, наприклад, щоб один раз зчитати конфігурацію на старті програми.
// У більшості випадків краще використовувати асинхронні версії.

// Читання файлу

// fs.readFileSync(path, options) — синхронне читання вмісту файла.Приймає шлях до файлу та, за потреби,
//   кодування("utf8", "ascii" тощо).Якщо кодування не вказано, повертає Buffer, якщо вказано — звичайний рядок.

// import fs from "node:fs";

// // приклад без кодування
// const buffer = fs.readFileSync("file.txt");
// console.log(buffer); // <Buffer 48 65 6c 6c 6f ...>

// // приклад із кодуванням
// const data = fs.readFileSync("file.txt", "utf8");
// console.log("Вміст файлу:", data); // "Hello"

// fs.readFile(path, options) — асинхронне читання вмісту файла. Приймає шлях і опції. Повертає Promise, який у разі успіху містить або Buffer, або рядок (залежно від того, чи вказано кодування).

// import fs from "node:fs/promises";

// // без кодування
// const buffer = await fs.readFile("file.txt");
// console.log(buffer); // <Buffer ... >

// // з кодуванням
// const data = await fs.readFile("file.txt", "utf8");
// console.log("Вміст файлу:", data); // "Hello"

// У Node.js Buffer — це спеціальний тип даних для зберігання двійкової інформації(наприклад, вмісту файлів).Якщо потрібно
// працювати з текстом, достатньо вказати кодування, і тоді результатом буде звичайний рядок.

// Запис у файл

// fs.writeFileSync(path, data, options) — синхронний запис у файл. Якщо файл існує — перезапише його, якщо ні — створить новий.

// import fs from "node:fs";

// fs.writeFileSync("output.txt", "Привіт з Node.js!", "utf8");

// fs.writeFile(path, data, options) — асинхронний запис у файл. Повертає Promise, що виконується після завершення операції.

// import fs from "node:fs/promises";

// await fs.writeFile("output.txt", "Привіт з Node.js!", "utf8");
// console.log("Дані успішно записані у файл.");

// Додавання у файл

// fs.appendFile(path, data, options) — асинхронне додавання у файл. Дописує дані в кінець файлу.

// import fs from "node:fs/promises";

// await fs.appendFile("output.txt", "\\nЩе один рядок", "utf8");
// console.log("Дані успішно додані у файл.");

// Перейменування / переміщення файлів

// fs.rename(oldPath, newPath) — асинхронне перейменування або переміщення файлу. Повертає Promise.

// import fs from "node:fs/promises";

// await fs.rename("oldfile.txt", "newfile.txt");
// console.log("Файл успішно перейменовано.");

// Видалення файлу

// fs.unlink(path) — асинхронне видалення файлу. Повертає Promise.

// import fs from "node:fs/promises";

// await fs.unlink("file.txt");
// console.log("Файл успішно видалено.");

// Підсумок

// path — для правильного формування шляхів у різних ОС.
// fs — для роботи з файлами та папками.
// Синхронні методи зручні для одноразових операцій (наприклад, читання конфігів на старті).
// В реальних застосунках використовуємо асинхронні методи (fs/promises), бо вони не блокують виконання.

// Ці два модулі є базовими інструментами у Node.js, і розуміння їхньої роботи — перший крок до створення повноцінних серверних застосунків.

//!  Тип даних Buffer

// При роботі з файловою системою ви часто будете бачити об’єкти типу Buffer. Це спеціальний тип даних у Node.js, призначений для роботи з двійковими даними.

// Біт — це найменша одиниця інформації: 0 або 1.
// Байт — це 8 бітів. У такій комбінації можна представити 256 різних значень.

// Buffer у Node.js — це масив байтів. Кожен байт може зберігати невелике значення (наприклад, код символу).

// import fs from "node:fs/promises";

// const buffer = await fs.readFile("hello.txt");
// // якщо у файлі hello.txt був текст "Hello World!"

// console.log(buffer);
// // <Buffer 48 65 6c 6c 6f 20 57 6f 72 6c 64 21>

// Вивід <Buffer ...> показує набір байтів у шістнадцятковій системі (hex). Кожен байт відповідає одному символу або службовому знаку (наприклад, пробілу).

// Кодування

// Файл завжди зберігається як набір байтів. Але щоб інтерпретувати його вміст як текст, потрібно знати кодування.

// Найпоширеніше текстове кодування — UTF-8. Саме воно дозволяє перетворити байти у символи:

// import fs from "node:fs/promises";

// const buffer = await fs.readFile("hello.txt");
// console.log(buffer.toString("utf-8")); // Hello World!

// Якщо при читанні файлу одразу вказати кодування("utf8"), результатом буде рядок, а не Buffer.Якщо кодування не
// вказано — повертається Buffer.

// Висновок

// Buffer — це масив байтів.
// Якщо методи fs.readFile/fs.readFileSync викликати без кодування, результатом буде Buffer.
// Якщо вказати кодування ("utf8"), результатом буде звичайний рядок.
// Розуміння Buffer стане в пригоді при завантаженні файлів та роботі з двійковими даними (наприклад, зображеннями).

//!  Фронтенд та бекенд

// Вебзастосунок складається з двох основних частин: фронтенду та бекенду.

//   Фронтенд — це все, що бачить і з чим взаємодіє користувач: вебсторінка, кнопки, форми, стилі.Він працює у браузері та написаний
// здебільшого на HTML, CSS, JavaScript(або фреймворках на їх основі — React, Vue, Angular).
//   Бекенд — це серверна частина.Вона отримує запити від фронтенду, обробляє їх і повертає відповіді.Користувач її безпосередньо
// не бачить, але без бекенду неможливий жоден сучасний вебсервіс.

// З чого складається бекенд

// У більшості випадків бекенд включає два головні компоненти:

// Вебсервер – програма, яка приймає HTTP - запити від клієнтів(браузерів, мобільних застосунків) і повертає HTTP - відповіді.
//  У Node.js для цього часто використовують Express.js.
// База даних – система зберігання інформації.Уявіть інтернет - магазин: дані про товари, користувачів, замовлення
// зберігаються в базі даних, а бекенд отримує їх і відправляє клієнту.Приклади: MongoDB, PostgreSQL, MySQL.

// Додатково бекенд може включати:

// Авторизацію та автентифікацію (керування доступом користувачів).
// Файлове сховище (наприклад, для зображень чи документів).
// Зовнішні інтеграції (платіжні системи, сторонні API).
// Логіку бізнес-процесів (наприклад, розрахунок вартості замовлення або перевірка доступності товару).

// Як це працює
// Користувач у браузері натискає кнопку → фронтенд відправляє HTTP-запит на сервер.
// Вебсервер приймає цей запит і вирішує, що з ним робити: звернутися до бази даних, виконати бізнес - логіку, віддати файл чи
// повідомлення про помилку.
// Сервер формує відповідь і надсилає її назад фронтенду.
// Фронтенд показує результат користувачу.

//!  REST API

// Перш ніж писати власний бекенд і працювати з HTTP - запитами в Node.js, нагадаємо, що таке REST API.Ви вже користувалися ним у
// фронтенді, коли отримували чи відправляли дані на сервер.

// REST (Representational State Transfer) API — це спосіб побудови вебсервісів, який визначає, як клієнт і сервер взаємодіють через Інтернет.

// Простіше кажучи: REST API описує правила, за якими клієнт (наприклад, браузер) може попросити дані у сервера або надіслати йому нові.

// Уявіть, що сервер — це поштове відділення, а REST API — це правила, як саме ми можемо відправляти і отримувати листи чи пакунки.

// Ресурси

// Ресурс — це сутність, з якою працює сервер.

// У поштовому відділенні ресурсом є лист або посилка.
// У бібліотеці — книга.
// В університеті — студент.
// Наприклад, ресурс «студент» може виглядати так:

// {
//   "id": 123,
//   "name": "John Doe",
//   "age": 16,
//   "gender": "male",
//   "onDuty": false
// }

// Методи запиту

// Метод — це дія, яку клієнт хоче виконати над ресурсом.

// У поштовому відділенні ви можете отримати лист, відправити пакунок чи змінити адресу. У REST API діють схожі принципи:

// GET — отримати ресурс (наприклад, список студентів).
// POST — створити новий ресурс.
// PUT — повністю оновити ресурс або створити новий.
// PATCH — частково оновити ресурс.
//   DELETE — видалити ресурс.

// Шляхи (роути)

// Щоб знайти ресурс, потрібна його адреса. У REST API це URL.

// https://example.com/students — усі студенти.
// https://example.com/students/123 — студент із id=123.
// https://example.com/students/123/homeworks — усі домашні роботи студента №123.

// Зверніть увагу: назви сутностей пишемо у множині(students, homeworks).Частина 123 — це динамічний параметр, який
// можна замінити іншим id.

// Параметри запиту

// Іноді потрібно уточнити результат: відсортувати чи відфільтрувати дані.Для цього використовують query parameters
// (параметри запиту).Вони пишуться після ? у URL.

// Приклад:

// https://example.com/students?order=asc&search=joe&page=1&per_page=10

// Такий запит може повернути перших 10 студентів, відсортованих у порядку зростання, чиї імена містять «joe».

// Приклади REST-запитів

// Отримати всіх студентів:

// GET https://example.com/students

// Оновити дані студента з id=123:

// PATCH https://example.com/students/123

// Видалити домашнє завдання з id=456 у студента №123:

// DELETE https://example.com/students/123/homeworks/456

// Короткий підсумок

// REST API — це набір правил, як клієнт може звертатися до сервера за допомогою HTTP-запитів.

// Він визначає:

// які є ресурси,
// які дії можна над ними виконувати (методи),
// які адреси мають ці ресурси (шляхи),
// як уточнювати запит (параметри).
// Це схоже на поштову систему: у вас є адреса (URL), спосіб доставки (метод) і сам вміст (ресурс).

// Перегляньте запит

// GET https://api.example.com/books?genre=fiction&author=John+Doe

// // todo
// Виберіть найкраще тлумачення такого запиту:

// отримати книгу з id fiction, автор якої будь-хто, окрім John Doe
// видалити книгу із жанром fiction та автором John Doe
// + отримати всі книги, жанр яких — fiction, а автор — John Doe
// створити нову книгу із жанром fiction та автором John Doe
// Result

// The answer is correct

//!  Postman

// Щоб перевіряти, як працює ваш бекенд, потрібні інструменти для тестування HTTP-запитів.

// Ми будемо користуватися Postman, бо він має все необхідне для роботи з API: можна створювати запити, відправляти їх
// на сервер, перевіряти відповіді й навіть документувати API.

// Postman — це програма для тестування та розробки API з простим і зручним інтерфейсом.

// Можливості Postman

// Надсилання HTTP-запитів — легко створювати GET, POST, PUT, PATCH, DELETE та інші запити.
// Тестування API — можна писати прості тести на JavaScript для перевірки роботи вашого коду.
// Організація запитів — усі запити зручно зберігати у колекціях.
// Зразки даних — можна зберігати типові JSON-об’єкти для швидкого тестування.
// Документація API — Postman автоматично генерує документацію на основі ваших колекцій.

// Postman можна встановити на Windows, macOS, Linux або як розширення для браузера. Завантаження: postman.com/downloads.

// Дивись відео з папкм Node - назвою: Postman

// Радимо активно тренуватися з Postman! Для цього можна використати безкоштовний тестовий бекенд — JSONPlaceholder.
// Це чудовий спосіб відправляти реальні HTTP - запити й бачити відповіді у форматі JSON.

//!  Заняття 2. Знайомство з

// Express — мінімалістичний веб-фреймворк для Node.js. Він спрощує створення HTTP-серверів та REST API:

// маршрутизація (обробка шляхів і методів HTTP);
// конвеєр middleware (до/після обробки запиту);
// зручні методи відповіді (res.json, res.status тощо).
// Express не нав’язує ORM, шаблонізатори чи архітектуру — ці речі додаєш за потреби.

// Створення вебсервісу

// Встанови пакет:

// npm install express

// Мінімальний застосунок (app boilerplate) — файл src/server.js:

// // src/server.js
// import express from 'express';

// const app = express();
// const PORT = 3000;

// // Перший маршрут
// app.get('/', (req, res) => {
//   res.status(200).json({ message: 'Hello world!' });
// });

// // Запуск сервера
// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// Порт — номер “входу” для мережевих з’єднань твоєї програми (тут 3000). Усі запити на цей порт обробляє твій сервер.

// Онови скрипт запуску в package.json:

// // package.json

// {
//   "scripts": {
//     "dev": "nodemon src/server.js"
//   }
// }

// Запусти у dev-режимі (ми вже налаштували nodemon у попередньому занятті):

// npm run dev

// Перейди в браузері або зроби GET запит у POSTMAN на http://localhost:3000 — побачиш JSON-відповідь.

// Маршрути та обробники

// У вебсервері важливо вміти реагувати на різні шляхи (routes) та HTTP-методи. Для цього в Express використовуються методи об’єкта app.

// Кожен маршрут складається з:

// HTTP-методу (GET, POST, PUT, PATCH, DELETE).
// Шляху (наприклад, /, /users, /products/:id).
// Функції-обробника (callback) — виконується щоразу, коли сервер отримує запит, що підходить під метод і шлях.

// Функція-обробник завжди має два аргументи:

// req (request) — об’єкт запиту. Містить інформацію про сам HTTP-запит: шлях, параметри, тіло, заголовки.
// res (response) — об’єкт відповіді. Використовується для формування і відправки відповіді клієнту.

// Перший маршрут:

// // GET-запит до кореневого маршруту "/"
// app.get('/', (req, res) => {
//   res.status(200).json({
//     message: 'Hello world!',
//   });
// });

// Що тут відбувається:

// app.get — ми реєструємо маршрут для GET-запитів.
// '/' — шлях. Це означає, що маршрут спрацює при запиті до http://localhost:3000/.
// (req, res) => { ... } — функція-обробник. Вона виконається автоматично, коли на сервер прийде GET-запит до цього шляху.
// res.status(200) — встановлюємо код відповіді 200 OK.
// res.json({ message: 'Hello world!' }) — відправляємо відповідь у форматі JSON.

// Маршрутів може бути скільки завгодно

// // GET-запит до кореневого маршруту "/"
// app.get('/', (req, res) => {
//   res.status(200).json({
//     message: 'Hello world!',
//   });
// });

// // GET-запит до маршруту "/health"
// app.get('/health', (req, res) => {
//   res.status(200).json({
//     status: 'Ok!',
//   });
// });

// Таким чином, кожен маршрут в Express — це правило: “як сервер має реагувати на конкретний метод і
// шлях”. За допомогою req ми отримуємо дані від клієнта, а через res відправляємо відповідь.

//!  Динамічні параметри в маршрутах

// У багатьох випадках потрібно отримати конкретний ресурс за його ідентифікатором: користувача за id, товар за id,
// статтю за slug тощо.Для цього в Express використовуються динамічні параметри.

// // Список усіх користувачів
// app.get('/users', (req, res) => {
//   res.status(200).json([{ id: 1, name: 'Alice' }]);
// });

// // Конкретний користувач за id
// app.get('/users/:userId', (req, res) => {
//   const { userId } = req.params;
//   res.status(200).json({ id: userId, name: 'Jacob' });
// });

// GET /users → повертає масив користувачів.
// GET /users/:userId → повертає дані одного користувача.

// У виразі шляху частина з двокрапкою (:userId) означає, що ця частина URL є змінною. Значення параметра потрапляє в об’єкт req.params.

// Приклади:

// Запит GET /users/5 → req.params.userId === "5".
// Запит GET /users/42 → req.params.userId === "42".

// Параметри завжди приходять у вигляді рядків. Якщо потрібне число, його треба конвертувати:

// const userId = Number(req.params.userId);

// Динамічні параметри дозволяють створювати маршрути, які працюють із конкретними ресурсами, а не лише з колекціями.

//!      Middleware у Express

// У Express запити проходять через ланцюжок проміжних обробників — middleware.

// Кожен middleware може змінювати об’єкти req і res, виконувати певні дії(логування, парсинг тіла запиту, перевірку доступу
//   тощо) і передавати обробку далі.

// Middleware додаються через метод app.use:

// app.use(middleware);          // для всіх маршрутів
// app.use('/path', middleware); // тільки для /path/*

// Звичайні middleware мають три аргументи:

// (req, res, next) => { ... }

// req — запит
// res — відповідь
// next — функція, яка передає обробку далі

// Якщо middleware не завершує обробку (res.json, res.send тощо), воно обов’язково має викликати next(). Інакше запит «зависне».

// Приклад: логування часу

// // src/server.js
// import express from 'express';

// const app = express();
// const PORT = 3000;

// // Логування часу
// app.use((req, res, next) => {
//   console.log(`Time: ${new Date().toLocaleString()}`);
//   next();
// });

// // Маршрут
// app.get('/', (req, res) => {
//   res.status(200).json({ message: 'Hello, World!' });
// });

// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// У цьому прикладі запит проходить такі етапи:

// Middleware логування часу.
// Обробник маршруту /.

// Порядок підключення middleware має значення: Express виконує їх у тому порядку, в якому вони оголошені в коді.

// Тепер при GET-запиті сервер буде логувати час і дату у консоль:

// Middleware обробки помилок

// У Express є спеціальний тип middleware, який обробляє помилки. Його особливість у тому, що він завжди має чотири аргументи:

// (err, req, res, next) => { ... }

// err — об’єкт помилки
// req — запит
// res — відповідь
// next — функція для передачі далі (зазвичай не використовується, бо обробку завершує це middleware)

// Express автоматично передає сюди помилки, якщо попереднє middleware або маршрут викликав next(err) чи виникла синхронна помилка.

// Таке middleware завжди підключається останнім після усіх звичайних middleware та маршрутів, інакше воно не перехопить помилки.

// Доповнимо наш приклад з логуванням додавши middleware обробки помилок:

// // src/server.js
// import express from 'express';

// const app = express();
// const PORT = 3000;

// // Логування часу
// app.use((req, res, next) => {
//   console.log(`Time: ${new Date().toLocaleString()}`);
//   next();
// });

// // Маршрут
// app.get('/', (req, res) => {
//   res.status(200).json({ message: 'Hello, World!' });
// });

// // Маршрут для тестування middleware помилки
// app.get('/test-error', (req, res) => {
//   // Штучна помилка для прикладу
//   throw new Error('Something went wrong');
// });

// // Middleware для обробки помилок
// app.use((err, req, res, next) => {
//   console.error('Error:', err.message);
//   res.status(500).json({
//     message: 'Internal Server Error',
//     error: err.message,
//   });
// });

// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// Пізніше ми повернемось до middleware обробки помилок і вдосконалимо її.

// Давайте протестуємо цей код у Postman.У відео нижче ви побачите, як працює маршрут / і як error middleware обробляє штучну
// омилку на маршруті / test - error.
// Дивись відео в папкі Node - Відео до конспекту за такою назвою:
// "5. Модуль 1. Основи Node.js - Middleware у Express"
// Якщо не додати error middleware, сервер просто завершить запит без відповіді, а клієнт отримає «завислий» запит.

//!  Middleware для неіснуючих маршрутів

// Бувають ситуації, коли клієнт звертається до маршруту, якого не існує, тобто до URL, який наш сервіс не підтримує.
// Щоб коректно обробляти такі запити, у Express додають спеціальне middleware для 404 Not Found.

// app.use((req, res) => {
//   res.status(404).json({ message: 'Route not found' });
// });

// Особливість цього middleware у тому, що воно підключається після всіх маршрутів, але перед middleware для обробки
// помилок.Якщо жоден із маршрутів не збігся, керування дійде сюди.

// // src/server.js
// import express from 'express';

// const app = express();
// const PORT = 3000;

// // Логування часу
// app.use((req, res, next) => {
//   console.log(`Time: ${new Date().toLocaleString()}`);
//   next();
// });

// // Кореневий маршрут
// app.get('/', (req, res) => {
//   res.status(200).json({ message: 'Hello, World!' });
// });

// // Маршрут для тестування middleware помилки
// app.get('/test-error', (req, res) => {
//   // Штучна помилка для прикладу
//   throw new Error('Something went wrong');
// });

// // Middleware 404 (після всіх маршрутів)
// app.use((req, res) => {
//   res.status(404).json({ message: 'Route not found' });
// });

// // Middleware для обробки помилок (останнє)
// app.use((err, req, res, next) => {
//   console.error('Error:', err.message);
//   res.status(500).json({
//     message: 'Internal Server Error',
//     error: err.message,
//   });
// });

// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// У цьому прикладі обробка запиту проходить так:

// Middleware логування часу.
// Якщо шлях /, виконується обробник маршруту.
// Якщо шлях не знайдено — спрацьовує 404 middleware.
// Якщо виникла помилка — спрацьовує error middleware.

// Таким чином клієнт завжди отримає зрозумілу відповідь:
// - або дані,
// - або повідомлення про відсутність маршруту,
// - або опис помилки.

// Тепер при GET - запиті на будь - який неіснуючий маршрут, наприклад http://localhost:3000/random, сервер поверне відповідь
// із повідомленням про відсутність маршруту.

// !  Middleware із бібліотек

// Багато типових завдань у вебзастосунках вже вирішені готовими бібліотеками.У цьому розділі розглянемо три найпоширеніші приклади:
// робота з JSON, підтримка CORS і логування запитів.

// Обробка JSON

// Більшість сучасних вебзастосунків обмінюються даними у форматі JSON.У Express для цього є вбудоване middleware — express.json().
// Воно автоматично парсить(розпаковує) тіло HTTP - запиту, якщо воно надійшло у форматі JSON, і додає його у req.body.

// // src/server.js
// import express from 'express';

// const app = express();
// const PORT = 3000;

// // Middleware для парсингу JSON
// app.use(express.json());

// app.post('/users', (req, res) => {
//   console.log(req.body); // тепер тіло доступне як JS-об’єкт
//   res.status(201).json({ message: 'User created' });
// });

// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// Тепер, якщо відправити POST - запит із JSON - тілом, сервер автоматично розпарсить його і збереже у req.body як JavaScript - об’єкт.
// У нашому прикладі ми ще не використовуємо POST чи PATCH маршрути, але express.json() настільки базове та поширене middleware,
//   що його варто підключати одразу.

// CORS

// CORS (Cross-Origin Resource Sharing) — механізм безпеки, який дозволяє браузеру робити запити з одного домену до іншого.

// Наприклад, ваш фронтенд працює на http://localhost:3000, а бекенд — на http://localhost:5000. Без CORS браузер заблокує такі запити.

// Щоб дозволити обмін даними, сервер має вказати у відповідях спеціальний заголовок:

// Access-Control-Allow-Origin: *

// Це означає, що доступ дозволений з будь-якого джерела. В Express для цього використовують пакет cors:

// npm install cors

// Підключення у коді:

// // src/server.js
// import express from 'express';
// import cors from 'cors';

// const app = express();

// app.use(express.json());
// app.use(cors()); // Дозволяє запити з будь-яких джерел

// // Решта коду

// У більш складних випадках можна задавати конкретні домени чи методи, але для базового застосунку цього достатньо.

// Логування запитів

// Логування допомагає відслідковувати, як працює застосунок: які запити надходять, які відповіді повертаються і скільки часу займає обробка.

// Ми використаємо сучасний логер pino-http. Він дуже швидкий і простий у налаштуванні.

// Встановлення:

// npm install pino-http pino-pretty

// Підключення у коді:

// // src/server.js
// import express from 'express';
// import cors from 'cors';
// import pino from 'pino-http';

// const app = express();
// const PORT = 3000;

// // Middleware
// app.use(express.json());
// app.use(cors());
// app.use(
//   pino({
//     level: 'info',
//     transport: {
//       target: 'pino-pretty',
//       options: {
//         colorize: true,
//         translateTime: 'HH:MM:ss',
//         ignore: 'pid,hostname',
//         messageFormat: '{req.method} {req.url} {res.statusCode} - {responseTime}ms',
//         hideObject: true,
//       },
//     },
//   }),
// );

// // Решта коду

// Налаштування Pino досить гнучкі — можна створити будь - який формат логів.У нашому випадку ми використовуємо готову
// конфігурацію, яка робить повідомлення у консолі зручними та читабельними: кольоровий текст, час запиту, HTTP - метод,
//   шлях і статус відповіді.

//!   Змінні оточення

// Будь - який застосунок має працювати в різних середовищах: на локальному комп’ютері, у тестовому середовищі чи на продакшені.
// Для кожного з них можуть відрізнятися налаштування: адреси баз даних, API - ключі, секрети або інші параметри.Саме для цього існують змінні оточення.

// Змінні оточення(environment variables) — це змінні, що зберігають конфігураційні параметри програми.Вони дозволяють винести
// чутливу або специфічну для середовища інформацію за межі коду.

// Зазвичай такі змінні оголошуються у файлі .env, який створюється в корені проєкту. Наприклад, порт, на якому запускається сервер:

// # .env

// PORT=3000

//   .env обов’язково додається в.gitignore і ніколи не комітиться в репозиторій.Якщо випадково закомітили — потрібно негайно змінити
// всі ключі й паролі.Навіть видалення файлу у наступному коміті не прибере його з історії.

// Доброю практикою є створення файлу.env.example, де перелічуються всі змінні без реальних значень.Це допомагає іншим розробникам
// налаштувати своє середовище:

// # .env.example

// PORT=9999

// Використання змінних у коді

// Щоб зчитувати .env, встановлюємо пакет dotenv:

// npm install dotenv

// Імпортуємо його у коді:

// // src/server.js

// // Такий імпорт одразу ініціалізує бібліотеку
// import 'dotenv/config';

// У Node.js змінні доступні через глобальний об’єкт process.env:

// // src/server.js

// import express from 'express';
// import cors from 'cors';
// import pino from 'pino-http';
// import 'dotenv/config';

// const app = express();

// // Використовуємо значення з .env або дефолтний порт 3000
// const PORT = process.env.PORT ?? 3000;

// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// Значення у process.env завжди є рядками.Якщо потрібен інший тип(наприклад число чи булеве значення), його слід явно конвертувати.
// Використання дефолтного значення(?? 3000) захистить від ситуацій, коли змінна у.env ще не вказана.

// Middleware обробки помилок

// Наша мідлвара для обробки помилок у поточному вигляді завжди відправляє користувачу деталі помилки(err.message).Це зручно під
// час розробки, але в продакшені так робити небезпечно — користувач може побачити внутрішню інформацію про застосунок.

// Щоб вирішити цю проблему, ми додамо змінну оточення NODE_ENV, яка буде вказувати, у якому середовищі працює застосунок:

// development — режим розробки (показуємо деталі помилки і стек).
// production — продакшн (повертаємо лише загальне повідомлення).

// Оновлюємо файл .env у корені проєкту:

// #.env
// PORT=3000
// NODE_ENV=development

// Тепер під час локальної розробки process.env.NODE_ENV матиме значення development.

// Оновлений код middleware:

// // src/server.js

// // Решта коду файла

// // Middleware для обробки помилок
// app.use((err, req, res, next) => {
//   console.error(err);

//   const isProd = process.env.NODE_ENV === "production";

//   res.status(500).json({
//     message: isProd
//       ? "Something went wrong. Please try again later."
//       : err.message,
//   });
// });

// // Решта коду файла

// При деплої продакшн - версії на Render.com змінна NODE_ENV автоматично матиме значення "production", навіть якщо ви її не задавали.
// Це гарантує, що у продакшені деталі помилок не потраплять у відповідь.

//!   Деплой бекенда

// Ви вже знайомі з поняттям деплой, адже раніше розгортали фронтенд - застосунки(наприклад, на Vercel чи Netlify).
// Тепер настав час зрозуміти, як відбувається деплой бекенда.

//   Фронтенд — це статичні файли(HTML, CSS, JS), які сервер просто віддає користувачеві.Коли ви деплоїте фронтенд, хостинг
// лише зберігає ці файли та робить їх доступними у браузері.

//   Бекенд — це вже живий застосунок, який постійно працює у пам’яті сервера, слухає порт і обробляє HTTP - запити.Тобто,
//     коли ми деплоїмо бекенд, ми фактично запускаємо програму на віддаленому комп’ютері, доступну 24 / 7.

// Render.com

// Для розгортання бекенда ми будемо використовувати Render.com — платформу, яка автоматизує запуск Node.js-додатків.

// Вона бере ваш код із GitHub, встановлює залежності, запускає сервер і робить його доступним у мережі.

// Render зручно підходить для навчальних і продакшн-проєктів, бо:

// підтримує безкоштовний тариф,
// має просту інтеграцію з GitHub,
// дозволяє налаштовувати змінні оточення (наприклад, PORT чи ключі до БД),
// автоматично видає публічний HTTPS-URL.

// При деплої на Render.com вам не потрібно вручну створювати змінну NODE_ENV. Сервіс автоматично встановить її значення в "production", навіть якщо ви цього не зробите самі. Це означає, що ваш застосунок одразу працюватиме у безпечному продакшн-режимі, де деталі помилок не відправляються користувачу.

// Детальні кроки ви побачите у відео, де ми розбираємо процес деплою бекенда на render.com.
// Дивись відео в папкі Node - Відео до конспекту за такою назвою:
// "6. Модуль 1. Основи Node.js - Деплой бекенда на Render.com"

// todo TASK

// Критерії приймання

// Створений репозиторій з назвою nodejs-hw
// Завдання виконано на гілці 01-express
// Надано посилання на вихідний код у GitHub
// Надано посилання на задеплоєний проєкт на render.com
// Код виконується без помилок
// Використовується змінна PORT через dotenv
// Підключено cors
// Підключено express.json()
// Налаштований логер pino-http
// Додано middleware для 404
// Додано middleware для помилок 500
// Файлова структура відповідає вимогам
// Реалізований маршрут GET /notes
// Реалізований маршрут GET /notes/:noteId
// Реалізований маршрут GET /test-error

// Створення проєкту

// Ініціалізуйте проєкт командою npm init -y

// Додайте в залежності проєкта eslint та підкорегуйте його конфігураційний файл згідно наданого прикладу в матеріалах.

// Додайте у корінь проєкта файли .gitignore та .prettierrc з відповідним вмістом.

// Встановіть nodemon як залежність для розробки.Додайте скрипт "start", "dev" у файл package.json, щоб запускати сервер за допомогою
// nodemon.Для цього відредагуйте розділ scripts.

// Файлова структура

// Створіть в корні проєкта папку src.

// В папці src створіть файл із назвою server.js.В ньому буде знаходитись логіка роботи вашого express - серверу.У вас має вийти
// наступна структура файлів і папок:

// Така структура потрібна, щоб відділити логіку додатка (src) від конфігурації та допоміжних файлів, що лежать у корені проєкту.

// Змінні оточення

// Створіть файл .env для зберігання змінних, додайте в нього змінну PORT.

// Запуск express - сервера має відбуватись на порті, вказаному через змінну оточення PORT або 3000, якщо такої змінної не було отримано.
// Використайте пакет dotenv для її підвантаження.

// Реалізація маршрутів

// Поки у нас немає повноцінної бази даних, наш express - сервер тимчасово буде повертати не повноцінні дані про нотатки, а
// об’єкт з відповідним повідомленням.

// Ваш сервер має надавати такі маршрути для роботи з нотатками:

// маршрут, який буде повертати всі нотатки:

// GET /notes

// Відповідь сервера має бути зі статусом 200 та містити наступний об'єкт:
// {
// 	"message": "Retrieved all notes"
// }

// маршрут, який буде повертати одну нотатку за її ідентифікатором:
// GET /notes/:noteId

// Відповідь сервера має бути зі статусом 200 та містити наступний об'єкт:
// {
// 	"message": "Retrieved note with ID: id_param"
// }

// де id_param — це значення параметра noteId із запиту.

// Middleware

// Додайте до вашого серверу стандартні Middleware:

// cors — дозволяє робити запити з інших доменів;
// express.json() — дозволяє обробляти дані у форматі JSON, які надходять у body запиту.

// Додайте до вашого серверу Middleware для логування:

// У файлі src / server.js налаштуйте логування HTTP - запитів за допомогою пакета pino - http.Це допоможе бачити, які запити
// надходять на сервер.

// Обробка неіснуючих маршрутів

// Додайте до src/server.js middleware для обробки всіх запитів, що не відповідають жодному наявному маршруту.

// Відповідь сервера у такому випадку має бути зі статусом 404 та містити наступний об'єкт:

// {
//   "message": "Route not found"
// }

// Наприклад, якщо надійдуть такі запити:

// GET /profile
// GET /payments

// — цей middleware повинен їх перехопити та відповісти 404, бо ці маршрути не реалізовані у вашому сервері.

// Обробка помилок

// У файлі src/server.js реалізуйте middleware що перехоплює помилки.

// Відповідь сервера у такому випадку має бути зі статусом 500 та містити наступний об'єкт з повідомленням про помилку:

// {
//   "message": <повідомлення про помилку>
// }

// Створіть спеціальний тестовий маршрут для імітації виникнення помилки:

// GET /test-error

// з таким обробником:

// app.get('/test-error', () => {
//   throw new Error('Simulated server error');
// });

// Деплой

// Задеплойте ваш додаток з гілки 01-express на render.com.

//     Дуже важливо перед здачею дз на перевірку ментору перевіряти роботу вашого задеплоєного додатка на render.com.
//     Якщо, наприклад, при деплої ви забули додати змінні оточення (env), то задеплоєний бекенд не буде працювати.
//     Також перевірте, що всі створені вами маршрути бекенду працюють як очікується згідно з завданням.

// Results
// Version 2/2
// Task 1

// Завдання вирішено правильно (файл src/server.js)

// Добре реалізовані аспекти:

// Сервер реалізовано з використанням Express та ES-модулів.
// Змінні середовища завантажуються через 'dotenv/config'.
// Сервер слухає порт, вказаний у PORT, або за замовчуванням використовує 3000.
// CORS увімкнено для всіх маршрутів.
// Додано middleware express.json().
// Логування HTTP-запитів інтегровано з використанням pino-http.
// Усі необхідні маршрути (/notes, /notes/:noteId, /test-error) реалізовані з правильною структурою відповіді.
// Невідомі маршрути обробляються зі статусом 404 та відповідним JSON-повідомленням.
// Присутнє middleware для обробки помилок, яке повертає JSON-відповідь.
// Сервер логгує повідомлення з вказанням порту, на якому працює.
// Додаткові пропозиції:

// Включення helmet є хорошою практикою безпеки, хоча для цього завдання це не обов’язково.
// Фінальне рішення:

// Завдання прийнято

//!  Заняття 3. Бази даних

// Що таке бази даних?

// Ви вже працювали з масивами та об’єктами у JavaScript. Це теж спосіб зберігати дані, але підходить лише для невеликих програм.

// А що робити, якщо потрібно зберігати тисячі чи навіть мільйони записів ? Наприклад, усіх користувачів Instagram або всі замовлення в
// інтернет - магазині ?

// Тут на допомогу приходять бази даних(БД).Вони є основою будь - якої сучасної системи: від маленьких сайтів до великих сервісів на
// кшталт YouTube чи Facebook.

// База даних (Database) — це організоване місце для зберігання даних, яке дозволяє їх швидко додавати, шукати, змінювати та видаляти.

// Основні характеристики баз даних

// Дані.База даних містить інформацію, яка може бути структурованою у вигляді таблиць, документів, ключів - значень, графів чи інших
// форматів — залежно від типу бази.
//   Маніпуляція.Бази даних дозволяють виконувати різні операції над даними: додавати нові записи, змінювати їх, видаляти чи знаходити
// за певними умовами.Для цього можуть використовуватись SQL - запити або інші мови.
//   Структура.Дані можуть бути організовані по - різному: у вигляді таблиць(реляційні БД), у вигляді документів(JSON - подібних об’єктів),
//     у графах, де важливі зв’язки між сутностями тощо.
// Збереження. Бази даних забезпечують довготривале зберігання інформації на дисках або інших носіях, навіть після перезавантаження системи.
//   Цілісність.СУБД(системи управління базами даних) мають механізми, які гарантують, що дані залишаються узгодженими й коректними,
//     навіть при великих обсягах чи паралельних запитах.
// Доступ. Бази надають ефективний спосіб доступу до даних для користувачів та програм, дозволяючи швидко знаходити потрібну інформацію.
// Безпека. Захист від несанкціонованого доступу та контроль прав користувачів є ключовими складовими будь-якої сучасної бази.

// Реляційні та нереляційні бази даних

// Усі бази даних можна поділити на два великі типи: реляційні та нереляційні.

// Реляційні бази даних

// Зберігають дані у вигляді таблиць (рядки та колонки).
// Між таблицями можна будувати зв’язки. Наприклад: таблиця users і таблиця orders, де кожне замовлення має посилання на користувача.
// Використовують мову SQL для роботи з даними.
// Добре підходять для структурованих даних і складних зв’язків.
// Приклади: MySQL, PostgreSQL, Oracle.

// Можна уявити реляційну БД як Excel-таблиці, але з дуже великими можливостями.

// Нереляційні бази даних

// Використовують інші структури даних:
// Документи (JSON-об’єкти).
// Ключ-значення (як словник у JS).
// Графи (зв’язки між елементами).
// Немає суворої схеми: кожен запис може мати свій набір полів.
// Легко масштабуються та зручні, коли структура даних часто змінюється.
// Приклади: MongoDB, Redis, Cassandra.

// Нереляційну БД можна уявити як велику колекцію об’єктів у JavaScript.

// MongoDB

// У нашому курсі ми будемо працювати з MongoDB.

// MongoDB — це нереляційна база даних, яка зберігає дані у вигляді документів, схожих на JavaScript-об’єкти:

// {
//   "id": 1,
//   "name": "Alice",
//   "email": "alice@mail.com"
// }

// Це робить MongoDB дуже зручною для фронтенд-розробників: дані виглядають так само як і у вашому JS-коді.

// Основні переваги MongoDB

// Гнучкість схеми. Можна додавати нові поля без змін у всій базі.
// Швидкість. Добре працює з великими обсягами даних.
// Масштабованість. Підтримує розподіл даних між кількома серверами.
// Надійність. Вміє створювати копії даних (реплікацію), щоб база працювала навіть при збоях.
// Зручність. Формат зберігання дуже схожий на JSON, тож працювати з ним легко.

// MongoDB використовують такі компанії, як eBay, Uber, Adobe, Lyft, LinkedIn.

//!  MongoDB Atlas

// Уявіть собі величезний склад, де зберігаються всі ваші дані.Так працює база даних MongoDB: вона зберігає інформацію у вигляді
// окументів, які виглядають як JavaScript - об’єкти.

// {
//   "id": 1,
//   "name": "Alice",
//   "email": "alice@mail.com"
// }

// MongoDB можна встановити локально на комп’ютер, але набагато зручніше користуватися її хмарною версією.

// MongoDB Atlas — це сервіс, який дозволяє створити та використовувати базу даних у хмарі.Вам не потрібно налаштовувати
// сервери вручну — достатньо зареєструватися, і ви отримаєте готовий кластер.

// Кластер — це група серверів, які працюють разом, щоб:

// база даних завжди була доступною,
// дані не зникли при збої,
// запити виконувались швидко навіть під великим навантаженням.

// Тобто, якщо звичайна база — це просто склад, то кластер у

// MongoDB Atlas — це склад із додатковими "охоронцями", резервними копіями та можливістю швидко збільшувати площу, якщо з’являється більше товару (даних).

// Створення акаунту

// Щоб почати роботу:

// Переходимо на MongoDB Atlas.
// Реєструємо акаунт.
// Створюємо кластер (це буде наша база в хмарі).

// Відео-демо процесу реєстрації:

// Дивись відео в папкі Node- відео до конспекту:

// "7. Модуль 2. Бази даних-MongoDB Atlas"

// Збереження даних підключення

// Після створення бази ви отримаєте спеціальний connection string — рядок підключення. Наприклад:

// mongodb+srv://borismeshkovaws:12345678@cluster0.xpxkilq.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0

// У код його додавати не можна — це небезпечно.Натомість ми збережемо ці дані у файлі.env, щоб зручно працювати з різними
// середовищами(локально, на тесті, у продакшені).

// # .env

// PORT=3000
// MONGO_URL=mongodb+srv://borismeshkovaws:12345678@cluster0.xpxkilq.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0

// І не забудьте оновити файл .env.example, щоб інші розробники бачили, які змінні треба налаштувати:

// # .env.example
// PORT=
// MONGO_URL=

// Підключення MongoDB

// Щоб працювати з базою даних, нам потрібно підключитися до неї зі свого бекенду.Робити це "вручну" через драйвер MongoDB
// незручно, тому ми використаємо бібліотеку Mongoose.

// Mongoose спрощує роботу з базою:

// дозволяє легко підключитися,
// працювати з колекціями як з об’єктами,
// будувати схеми та моделі для даних.

// Встановлюємо пакет у наш проєкт:

// npm install mongoose

// Файл для підключення

// Щоб код був структурованим, створимо у папці src нову папку db, а в ній файл connectMongoDB.js.Там ми напишемо функцію
// для підключення до бази даних.

// // src/db/connectMongoDB.js
// import mongoose from 'mongoose';

// export const connectMongoDB = async () => {
//   try {
//     const mongoUrl = process.env.MONGO_URL;
//     await mongoose.connect(mongoUrl);
//     console.log('✅ MongoDB connection established successfully');
//   } catch (error) {
//     console.error('❌ Failed to connect to MongoDB:', error.message);
//     process.exit(1); // аварійне завершення програми
//   }
// };

// Тут ми:

// читаємо рядок підключення (MONGO_URL) зі змінних оточення,
// викликаємо mongoose.connect(...) для встановлення з’єднання,
// у разі успіху виводимо повідомлення,
// у разі помилки завершуємо роботу процесу (process.exit(1)), щоб сервер не залишався "напівживим".

// Виклик у сервері

// У файлі src/server.js імпортуємо та викликаємо функцію перед запуском сервера:

// // src/server.js

// import express from 'express';
// import 'dotenv/config';
// import cors from 'cors';
// import { connectMongoDB } from './db/connectMongoDB.js';

// const app = express();
// const PORT = process.env.PORT ?? 3030;

// /* Middleware та маршрути */

// // підключення до MongoDB
// await connectMongoDB();

// // запуск сервера
// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// У сучасному Node.js ми можемо використовувати top - level await.Це означає, що await можна викликати прямо у файлі модуля,
//   а не тільки всередині async функції.Це зручно, бо дозволяє писати асинхронний код на верхньому рівні програми.

//!  MongoDB Compass
// Імпорт даних у MongoDB

// Працювати з базою даних можна різними способами: через командний рядок, напряму з коду або за допомогою зручних інструментів з графічним інтерфейсом. Для початку ми використаємо MongoDB Compass — офіційний інструмент зручної роботи з MongoDB.

// MongoDB Compass — це програма, яка дозволяє переглядати базу даних у зрозумілому віконному інтерфейсі. Вона значно полегшує роботу:

// можна переглядати колекції та документи,
// редагувати записи,
// виконувати пошук і фільтрацію,
// імпортувати та експортувати дані.

// Це хороший старт, бо дає можливість швидко ознайомитися з тим, як виглядають дані у базі.

// При завантаженні обирайте саме MongoDB Compass Download (GUI) — це потрібна нам версія.
// Встановлення MongoDB Compass

// Ось відеоінструкція з встановлення та перших кроків роботи:

// " 8. Модуль 2. Бази даних-MongoDB  Compass"

// Імпорт тестових даних

// Щоб мати з чим працювати далі на практиці, ми одразу додамо у базу даних тестову колекцію студентів. Для цього:

// 1. Завантажте файл із даними:

// students.json

// 2. Використайте функцію імпорту в Compass, щоб додати ці дані у нову базу даних Students.

// Відео з покроковою інструкцією:

// "9. Модуль 2. Бази даних-MongoDB  Compass"

// Після імпорту у вас з’явиться готова колекція студентів, яку ми будемо використовувати для навчання: шукати, змінювати,
// видаляти та додавати нові записи.

// Підключення до конкретної бази даних

// У MongoDB Atlas ми можемо працювати з багатьма базами даних в одному кластері.Але для нашого проєкту важливо, щоб сервер
// одразу підключався саме до тієї бази, з якою ми працюємо.

// Ми вже створили базу даних students, тому потрібно вказати її назву у змінній оточення.Для цього після mongodb.net / у
// connection string додаємо назву бази(students) перед параметрами ? retry....

// Файл .env тепер виглядає так:

// # .env

// PORT=3000
// MONGODB_URL=mongodb+srv://borismeshkovaws:12345678@cluster0.xpxkilq.mongodb.net/students?retryWrites=true&w=majority&appName=Cluster0

// Тепер при підключенні через Mongoose ми одразу працюємо з базою students.Це означає, що всі наші моделі та колекції будуть
// створюватися й зберігатися саме в цій базі.

// Mongoose читає повний рядок підключення з process.env.MONGODB_URL, тому код підключення в connectMongoDB лишається без змін.

//!  Модель даних

// У цьому модулі ми будемо створювати бекенд для адмін - панелі навчального закладу, де ведеться облік студентів.Тому нашою першою
// моделлю буде студент.

//   MongoDB — це документоорієнтована NoSQL база даних, яка зберігає дані у вигляді документів у форматі BSON(Binary JSON).Модель
// даних у MongoDB базується на колекціях і документах.

// Основні поняття MongoDB

// Колекція (Collection): група документів. Можна уявити як масив об’єктів.
// Документ (Document): основна одиниця даних. Це JSON-подібний об’єкт у форматі BSON.
// Поле (Field): пара «ключ-значення» всередині документа.
// Ідентифікатор (_id): унікальне поле, яке автоматично створюється для кожного документа.

// Основні поняття Mongoose

// Щоб працювати з MongoDB, ми будемо використовувати бібліотеку Mongoose, яка спрощує опис структури документів.У ній є кілька
// ключових понять:

// Схема (Schema): описує структуру документа (які поля і з якими типами будуть).
// Модель (Model): клас, створений на основі схеми. Використовується для роботи з колекцією.
// Документ (Document): конкретний екземпляр моделі, який відповідає запису в базі даних.

// Схема студента

// Створимо схему для документа студента. Для цього використаємо клас Schema з бібліотеки mongoose.

// // src/models/student.js

// import { Schema } from 'mongoose';

// const studentSchema = new Schema(
//   {
//     name: {
//       type: String,
//       required: true,
//       trim: true, // прибирає пробіли на початку та в кінці
//     },
//     age: {
//       type: Number,
//       required: true,
//     },
//     gender: {
//       type: String,
//       required: true,
//       enum: ['male', 'female', 'other'],
//     },
//     avgMark: {
//       type: Number,
//       required: true,
//     },
//     onDuty: {
//       type: Boolean,
//       default: false,
//     },
//   },
//   {
//     timestamps: true,
//     versionKey: false,
//   },
// );

// Пояснення

// type — тип даних (String, Number, Boolean).
// required — чи поле обов’язкове.
//   trim: true — автоматично видаляє зайві пробіли на початку та в кінці рядка.Корисно для текстових полів, таких як name, щоб уникнути
// збереження значень на кшталт " John ".
// enum — перелік допустимих значень (наприклад, для gender).
// default — значення за замовчуванням, якщо поле не передано.
// timestamps — автоматично додає createdAt і updatedAt.
// versionKey: false — вимикає службове поле __v.

// Модель студента

// Створимо модель Student на основі нашої схеми:

// // src/models/student.js

// import { model } from 'mongoose';

// /* Решта коду файла */

// export const Student = model('Student', studentSchema);

// Mongoose автоматично створить колекцію students у базі даних(назва береться у множині).Тепер ми можемо використовувати
// модель Student для взаємодії з колекцією: створювати нових студентів, отримувати список, оновлювати чи видаляти записи.

//!  Взаємодія з базою даних

// Тепер, коли ми вже маємо базу students та модель Student, додамо маршрути для взаємодії з нею.Почнемо з отримання всіх студентів
// та отримання одного студента за його id.

// Маршрут: отримати всіх студентів

// У цьому маршруті ми будемо звертатися до колекції students через вбудований метод Mongoose Student.find(), який повертає масив
// документів(може бути порожнім), що відповідають моделі Student.

// // src/server.js

// import { Student } from './models/student.js';
// // Код імпортів та підключення middleware бібліотек

// app.get('/students', async (req, res) => {
//   const students = await Student.find();
//   res.status(200).json(students);
// });

// // Код 404 та error middleware, підключення до бази даних та старт сервера
// Маршрут: отримати одного студента за id

// Для цього маршруту ми використаємо вбудований метод Mongoose Student.findById().Якщо документ із заданим ідентифікатором не
// буде знайдено, метод поверне null.У такому випадку ми повернемо статус 404.

// // src/server.js

// // Решта коду

// app.get('/students/:studentId', async (req, res) => {
//   const { studentId } = req.params;
//   const student = await Student.findById(studentId);

//   if (!student) {
//     return res.status(404).json({ message: 'Student not found' });
//   }

//   res.status(200).json(student);
// });

// // Решта коду

// Властивість params на об’єкті запиту req містить динамічні параметри маршруту.Кожне ім’я параметра відповідає властивості цього об’єкта,
//  а значення, передане в URL, стає значенням цієї властивості.

// Повний код із підключенням middleware

// // src/server.js

// import express from 'express';
// import 'dotenv/config';
// import cors from 'cors';
// import { connectMongoDB } from './db/connectMongoDB.js';
// import { Student } from './models/student.js';

// const app = express();
// const PORT = process.env.PORT ?? 3000;

// app.use(express.json());
// app.use(cors());

// // GET /students — список усіх студентів
// app.get('/students', async (req, res) => {
//   const students = await Student.find();
//   res.status(200).json(students);
// });

// // GET /students/:studentId — один студент за id
// app.get('/students/:studentId', async (req, res) => {
//   const { studentId } = req.params;
//   const student = await Student.findById(studentId);
//   if (!student) {
//     return res.status(404).json({ message: 'Student not found' });
//   }
//   res.status(200).json(student);
// });

// // Middleware 404
// app.use((req, res) => {
//   res.status(404).json({ message: 'Route not found' });
// });

// // Middleware для обробки помилок
// app.use((err, req, res, next) => {
//   console.error(err);

//   const isProd = process.env.NODE_ENV === "production";

//   res.status(500).json({
//     message: isProd
//       ? "Something went wrong. Please try again later."
//       : err.message,
//   });
// });

// await connectMongoDB();

// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// Тепер ми маємо:

// GET <http://localhost:3000/students> → повертає всіх студентів.
// GET <http://localhost:3000/students/:studentId> → повертає одного студента або 404, якщо такого немає.

//! Організація middleware

// Коли наш код зростає, важливо зберігати його структурованим і зрозумілим. Якщо всі middleware та маршрути будуть в одному
// файлі server.js, швидко виникне плутанина. Тому ми виносимо middleware в окремі файли. Це дає кілька переваг:

// легше читати код, бо кожен файл відповідає за одну конкретну задачу;
// простіше підтримувати — якщо треба змінити тільки логування або обробку помилок, ми працюємо з окремим файлом;
// масштабованість — у майбутньому легко додати нові middleware без засмічення server.js.

// Структура проєкту

// Створюємо в папці src нову папку middleware і кладемо туди наші кастомні middleware.

// src/
//   middleware/
//     errorHandler.js
//     notFoundHandler.js
//     logger.js
//   server.js

// Error middleware

// Перенесемо middleware для обробки помилок у файл errorHandler.js.
// // src/middleware/errorHandler.js

// app.use((err, req, res, next) => {
//   console.error(err);

//   const isProd = process.env.NODE_ENV === "production";

//   res.status(500).json({
//     message: isProd
//       ? "Something went wrong. Please try again later."
//       : err.message,
//   });
// });

// Це middleware має 4 аргументи (err, req, res, next) — саме за цим Express розуміє, що воно призначене для помилок.
// Використовується завжди останнім, щоб перехопити всі помилки з попередніх обробників.
// Ми виводимо помилку в консоль і повертаємо клієнту відповідь зі статусом 500 Internal Server Error.

// 404 middleware

// Тепер винесемо обробку випадку, коли клієнт звертається до неіснуючого маршруту. Для цього створимо notFoundHandler.js.

// // src/middleware/notFoundHandler.js

// export const notFoundHandler = (req, res) => {
//   res.status(404).json({ message: 'Route not found' });
// };

// Це middleware підключається після всіх маршрутів.
// Якщо жоден маршрут не збігся, керування потрапить сюди.
// Ми відправляємо клієнту відповідь зі статусом 404 Not Found.

// Логер Pino

// Щоб бачити всі запити, підключимо pino-http у logger.js.

// // src/middleware/logger.js

// import pino from 'pino-http';

// export const logger = pino({
//   level: 'info',
//   transport: {
//     target: 'pino-pretty',
//     options: {
//       colorize: true,
//       translateTime: 'HH:MM:ss',
//       ignore: 'pid,hostname',
//       messageFormat: '{req.method} {req.url} {res.statusCode} - {responseTime}ms',
//       hideObject: true,
//     },
//   },
// });

// Логер дозволяє відстежувати всі запити до сервера: метод (GET, POST), шлях, статус відповіді, час виконання.
// Ми використовуємо pino-pretty, щоб логи в консолі були кольоровими та зручними для читання.
// Логер треба підключати одним із перших middleware, щоб він бачив усі запити та помилки.

// Підключення в сервері

// Тепер у server.js імпортуємо всі ці middleware та використовуємо їх у правильному порядку.

// // src/server.js
// import express from 'express';
// import 'dotenv/config';
// import cors from 'cors';

// import { connectMongoDB } from './db/connectMongoDB.js';
// import { logger } from './middleware/logger.js';
// import { notFoundHandler } from './middleware/notFoundHandler.js';
// import { errorHandler } from './middleware/errorHandler.js';

// const app = express();
// const PORT = process.env.PORT ?? 3000;

// // Глобальні middleware
// app.use(logger);         // 1. Логер першим — бачить усі запити
// app.use(express.json()); // 2. Парсинг JSON-тіла
// app.use(cors());         // 3. Дозвіл для запитів з інших доменів

// // ...тут ваші маршрути

// // 404 — якщо маршрут не знайдено
// app.use(notFoundHandler);

// // Error — якщо під час запиту виникла помилка
// app.use(errorHandler);

// await connectMongoDB();

// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// Чому порядок важливий?

// Logger першим → логуються всі вхідні запити.
// JSON і CORS далі → кожен запит обробляється перед передачею в маршрути.
// Маршрути → відповідають на конкретні запити.
// 404 handler → якщо маршрут не знайдено.
// Error handler → якщо трапилась помилка на будь-якому етапі.

//!  Організація роутингу

// До цього ми писали обробники запитів безпосередньо у файлі server.js. Якщо маршрутів стає більше, зручніше винести їх у
// окремі файли й групувати за доменами (наприклад, students, auth, courses). Для цього є Express Router — об'єкт, який дозволяє
// групувати маршрути та їх обробники у логічні блоки.

// Створюємо роутер для студентів

// Створіть файл src/routes/studentsRoutes.js. Тут оголошуємо роутер і одразу експортуємо його. Це «порожня рамка», у яку додамо
// маршрути.

// // src/routes/studentsRoutes.js

// import { Router } from 'express';

// const router = Router();

// export default router;

// Переносимо обробники у роутер

// Далі переносимо контролери, які обробляють маршрути /students та /students/:studentId із файла server.js у файл роутингу
// studentsRoutes.js. Для їх оголошення замість app використовуємо створений router.

// // src/routes/studentsRoutes.js

// import { Router } from 'express';
// import { Student } from '../models/student.js';

// const router = Router();

// router.get('/students', async (req, res) => {
//   const students = await Student.find();
//   res.status(200).json(students);
// });

// router.get('/students/:studentId', async (req, res) => {
//   const { studentId } = req.params;
//   const student = await Student.findById(studentId);
//   if (!student) {
//     return res.status(404).json({ message: 'Student not found' });
//   }
//   res.status(200).json(student);
// });

// export default router;

// Підключаємо роутер

// Тепер імпортуємо створений роутер у файл server.js та додаємо його як middleware до app, за допомогою методу app.use().

// // src/server.js

// import express from 'express';
// import 'dotenv/config';
// import cors from 'cors';

// import { connectMongoDB } from './db/connectMongoDB.js';
// import { logger } from './middleware/logger.js';
// import { notFoundHandler } from './middleware/notFoundHandler.js';
// import { errorHandler } from './middleware/errorHandler.js';

// import studentsRoutes from './routes/studentsRoutes.js';

// const app = express();
// const PORT = process.env.PORT ?? 3000;

// // глобальні middleware
// app.use(logger);
// app.use(express.json());
// app.use(cors());

// // підключаємо групу маршрутів студента
// app.use(studentsRoutes);

// // 404 і обробник помилок — наприкінці ланцюжка
// app.use(notFoundHandler);
// app.use(errorHandler);

// await connectMongoDB();

// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// Підсумок

// Така організація коду створює зрозумілу структуру проєкту:

// server.js відповідає за складання застосунку та запуск сервера;
// роутери містять логіку для роботи з конкретними сутностями (у нашому випадку — студентами);
// моделі визначають доступ до бази даних.
// Цей підхід робить код більш чистим, масштабованим і зручним у підтримці.

//! Організація контролерів

// Ми вже винесли маршрути в окремий файл, але в ньому все ще залишилася логіка обробки запитів. Якщо маршрути будуть складнішими,
// код швидко стане важким для читання. Щоб уникнути цього, створимо окремий шар контролерів.

// Контролери — це функції, які відповідають за обробку запитів і формування відповіді. Роутер лише «знає», який контролер викликати
// для конкретного маршруту, а саму логіку ми зберігаємо в іншому місці. Це робить код більш організованим і зрозумілим.

// Створюємо контролери

// Створіть папку src/controllers, а в ній файл studentsController.js. У цей файл винесемо контролери, які зараз знаходяться у
// файлі studentsRoutes.js.

// // src/controllers/studentsController.js

// import { Student } from '../models/student.js';

// // Отримати список усіх студентів
// export const getStudents = async (req, res) => {
//   const students = await Student.find();
//   res.status(200).json(students);
// };

// // Отримати одного студента за id
// export const getStudentById = async (req, res) => {
//   const { studentId } = req.params;
//   const student = await Student.findById(studentId);

//   if (!student) {
//     return res.status(404).json({ message: 'Student not found' });
//   }

//   res.status(200).json(student);
// };

// Використовуємо контролери у роутері

// Тепер оновимо файл src/routes/studentsRoutes.js, щоб замість логіки напряму викликати контролери.

// // src/routes/studentsRoutes.js

// import { Router } from 'express';
// import {
// 	getStudents,
// 	getStudentById
// } from '../controllers/studentsController.js';

// const router = Router();

// router.get('/students', getStudents);
// router.get('/students/:studentId', getStudentById);

// export default router;

// Підсумок

// Ми винесли контролери в окремий файл і тепер маршрути виглядають більш чисто. Така організація дозволяє:

// відокремити логіку обробки запитів від опису маршрутів;
// полегшити підтримку та рефакторинг коду;
// підготувати ґрунт для подальшої роботи (наприклад, додавання нових методів чи валідації).

//!  Обробка помилок

// Уяви, що в кожному контролері ти вручну пишеш обробку помилок — це швидко перетворюється на хаос: дублювання коду, різні формати
// відповіді й зайва плутанина. Набагато зручніше мати єдине місце для обробки помилок — спеціальне middleware errorHandler яке у нас
// вже є.

// Для цього нам потрібно лише навчитися передавати помилки з контролерів у middleware. Це робиться за допомогою виклику next(error).

// Базова обробка помилки

// У контролері getStudentById метод Student.findById повертає null, якщо студент із переданим id не знайдений. Цей випадок потрібно
// обробити. Додамо параметр next у функцію та викличемо його у разі відсутності студента.

// Обов’язково після виклику next ставимо return, щоб припинити виконання коду в контролері.

// // src/controllers/studentsController.js

// // Додаємо третій параметр next до контролера
// export const getStudentById = async (req, res, next) => {
//   const { studentId } = req.params;
//   const student = await Student.findById(studentId);

//   // Код що був до цього
//   //  if (!student) {
//   //    return res.status(404).json({ message: 'Student not found' });
//   //  }

// 	// Додаємо базову обробку помилки замість res.status(404)
//   if (!student) {
//     next(new Error('Student not found'));
//     return;
//   }

//   res.status(200).json(student);
// };

// Виклик next передає управління наступному middleware у ланцюжку. Якщо забути написати return, код після next усе одно виконається —
// і це часта помилка початківців.

// Використання http-errors

// Але є нюанс: у цьому випадку ми створюємо «звичайну» помилку. Наш обробник (errorHandler) відповідає на неї кодом 500 Internal
// Server Error. Це неправильно, адже тут логічніше повернути 404 Not Found.

// Щоб робити це зручно, використаємо пакет http-errors. Він дозволяє створювати помилки з потрібним статусом і повідомленням.

// Встановлюємо пакет:

// npm install http-errors

// У контролері використовуємо функцію createHttpError:

// // src/controllers/studentsController.js
// import createHttpError from 'http-errors';

// export const getStudentById = async (req, res, next) => {
//   const { studentId } = req.params;
//   const student = await Student.findById(studentId);

//   if (!student) {
//     next(createHttpError(404, 'Student not found'));
//     return;
//   }

//   res.status(200).json(student);
// };

// Тепер замість «звичайної» помилки ми явно вказуємо код 404 і повідомлення.

// Оновлюємо errorHandler

// У middleware errorHandler також потрібно оновити код, щоб він відрізняв HTTP-помилки від інших.

// // src/middleware/errorHandler.js

// import { HttpError } from "http-errors";

// export const errorHandler = (err, req, res, next) => {
//   console.error("Error Middleware:", err);

//   // Якщо помилка створена через http-errors
//   if (err instanceof HttpError) {
//     return res.status(err.status).json({
//       message: err.message || err.name,
//     });
//   }

//   const isProd = process.env.NODE_ENV === "production";

//   // Усі інші помилки — як внутрішні
//   res.status(500).json({
//     message: isProd
//       ? "Something went wrong. Please try again later."
//       : err.message,
//   });
// };

// HttpError — це свідомо створені помилки, які ми самі генеруємо в коді (наприклад, createError(400, "Bad request"),
// createError(404, "Not Found") тощо). Такі повідомлення вважаються безпечними для користувача, оскільки вони не містять
// внутрішніх деталей застосунку чи бази даних. Тому їх можна повертати "як є" як у режимі розробки, так і в продакшені.

// А от для решти помилок ситуація інша. Їхні повідомлення можуть містити:

// частину Mongo-запиту,
// stack trace,
// назви внутрішніх змінних чи функцій.
// Таку інформацію небезпечно показувати у продакшені, тому:

// у development ми повертаємо реальний err.message, щоб було зручно дебажити,
// у production віддаємо лише загальне дружнє повідомлення, без деталей.

// Результат

// Тепер, якщо відправити запит на GET /students/:id із неіснуючим id, отримаємо у відповідь:

// статус: 404 Not Found,
// повідомлення: "Student not found".

// Таким чином ми винесли обробку помилок у єдине місце, зробили її більш правильною та зрозумілою для клієнта.

// !  Заняття 5. Валідація
// Вступ

// Вітаємо!

// У цьому модулі ми навчимося перевіряти правильність даних, які надходять у наш додаток в HTTP-запитах, а також працювати з великими обсягами даних у нашому застосунку. Це важливий етап, адже коли кількість записів зростає, нам потрібно їх захистити від помилок та зробити їх відображення зручним і зрозумілим для користувача.

// Ми розглянемо ключові інструменти:

// Валідація — перевірка правильності вхідних даних відповідно критеріїв.
// Пагінація — поділ даних на сторінки, щоб зменшити навантаження та спростити навігацію.
// Сортування — упорядкування даних за певними критеріями.
// Фільтрація — вибір конкретних даних за заданими умовами.

// Крок за кроком ми розберемо, як реалізувати кожен із цих інструментів у нашому бекенді.Це дозволить зробити застосунок більш ефективним, а роботу з даними — більш зручною для користувача.

//!   Валідація
// Навіщо потрібна валідація?

// Коли ми працюємо з бекендом, дані приходять із зовнішнього світу (наприклад, із форм на сайті чи від сторонніх клієнтів). Вони можуть мати будь-який формат. Якщо ми не перевіримо їх:

// у кращому випадку програма зламається;
// у гіршому — це може відкрити шлях до вразливостей у безпеці.

// Ми не можемо довіряти даним іззовні, тому перевіряємо їх на відповідність певним правилам:

// правильний тип (число, рядок, булеве значення);
// мінімальне та максимальне значення (для чисел);
// мінімальна та максимальна довжина (для рядків);
// відповідність одному зі списку значень;
// обов’язкові або необов’язкові поля.

// Цей процес і називається валідацією.

// Чому це так важливо?

// Перевірка даних, що надходять у запитах користувачів, має велике значення з кількох причин:

// допомагає зменшити площину атаки;
// захищає від атак на кшталт DDoS, cross-site scripting, command injection та SQL injection;
// забезпечує узгодженість даних;
// допомагає виявляти та фільтрувати шкідливі дані.

// Цей тип перевірки називається валідацією на стороні сервера (server-side validation), і він є критично важливим під час розробки застосунків. На щастя, існує кілька бібліотек, які беруть цю задачу на себе.

// Бібліотеки валідації

// Дві найпопулярніші бібліотеки для цього:

// Joi — мова опису схем об’єктів і валідатор.
// celebrate — дозволяє інтегрувати Joi безпосередньо у маршрути Express.

// Бібліотека celebrate вже містить Joi, тому достатньо встановити тільки її:

// npm i celebrate
//!   Схеми валідації
// Схеми валідації

// Joi — це бібліотека для валідації даних у Node.js. Вона дозволяє:

// створювати схеми для об’єктів;
// перевіряти об’єкти на відповідність цим схемам;
// налаштовувати повідомлення про помилки.

// Усі схеми ми зберігатимемо в окремій папці src/validations/. Для студентів це буде файл:

// src/validations/studentsValidation.js

// Базова схема валідації

// Визначення схем (Schema definition): ви можете повністю описати схеми для об'єктів, які бажаєте валідувати. Для цього використовуються методи Joi.object() та Joi.array() для структур, а також методи для примітивів (числа, рядки, булеві значення тощо). Схеми є зрозумілими та читаються майже як звичайні правила.

// Список усіх доступних правил є в офіційній документації.

// Приклад схеми для перевірки тіла запиту під час створення нового студента:

// import { Joi } from 'celebrate';

// const bodySchema = Joi.object({
//   name: Joi.string().min(3).max(30).required(),
//   age: Joi.number().integer().min(12).max(65).required(),
//   gender: Joi.string().valid('male', 'female', 'other').required(),
//   avgMark: Joi.number().min(2).max(12).required(),
//   onDuty: Joi.boolean(),
// });

// Тут ми описали правила для кожного поля. Наприклад, name має бути рядком довжиною від 3 до 30 символів і є обов’язковим.

// Використання Segments

// Далі потрібно визначити, яку саме частину HTTP-запиту ця схема має валідувати. Для цього ми експортуємо схему як об’єкт і через Segments вказуємо, що саме перевіряємо: body, params, query, headers чи cookies.

// Ось так виглядає схема для валідації тіла запиту:

// // src/validations/studentsValidation.js

// import { Joi, Segments } from "celebrate";

// export const createStudentSchema = {
//   [Segments.BODY]: Joi.object({
//     name: Joi.string().min(3).max(30).required(),
//     age: Joi.number().integer().min(12).max(65).required(),
//     gender: Joi.string().valid("male", "female", "other").required(),
//     avgMark: Joi.number().min(2).max(12).required(),
//     onDuty: Joi.boolean(),
//   }),
// };

// Segments — це набір «ключів», які визначають, яку саме частину запиту потрібно перевіряти:

// Segments.BODY → тіло запиту (req.body);
// Segments.PARAMS → параметри маршруту (req.params);
// Segments.QUERY → рядок запиту (req.query);
// Segments.HEADERS → заголовки (req.headers);
// Segments.COOKIES → кукі (req.cookies).

// Ми передаємо ці значення як ключі в об’єкті запиту.

// Наприклад, валідація параметра маршруту /notes/:category, де category — динамічний параметр:

// {
//   [Segments.PARAMS]: Joi.object({
//     category: Joi.string().valid('work', 'study', 'personal').required(),
//   })
// }

// У цьому випадку валідуються параметри маршруту, а саме :category.

// Якщо зробити запит GET /notes/work або GET /notes/personal — він пройде валідацію.
// Якщо ж зробити GET /notes/music — celebrate одразу поверне помилку 400 Bad Request, і контролер не виконається.

// Кастомізація повідомлень про помилки

// За замовчуванням повідомлення про помилки в Joi можуть бути незручними для користувачів: вони занадто технічні й складні для фронтенду.

// Тому варто робити власні повідомлення, щоб у відповіді віддавати більш зрозумілу інформацію — що саме пішло не так із валідацією. Це полегшує обробку помилок на клієнті й покращує досвід як для розробників, так і для користувачів.

// Ми можемо налаштовувати повідомлення через метод .messages():

// // src/validations/studentsValidation.js

// import { Joi, Segments } from 'celebrate';

// export const createStudentSchema = {
//   [Segments.BODY]: Joi.object({
//     name: Joi.string().min(3).max(30).required().messages({
//       "string.base": "Name must be a string",
//       "string.min": "Name should have at least {#limit} characters",
//       "string.max": "Name should have at most {#limit} characters",
//       "any.required": "Name is required",
//     }),
//     age: Joi.number().integer().min(12).max(65).required().messages({
//       "number.base": "Age must be a number",
//       "number.min": "Age must be at least {#limit}",
//       "number.max": "Age must be at most {#limit}",
//       "any.required": "Age is required",
//     }),
//     gender: Joi.string().valid("male", "female", "other").required().messages({
//       "any.only": "Gender must be one of: male, female, or other",
//       "any.required": "Gender is required",
//     }),
//     avgMark: Joi.number().min(2).max(12).required().messages({
//       "number.base": "Average mark must be a number",
//       "number.min": "Average mark must be at least {#limit}",
//       "number.max": "Average mark must be at most {#limit}",
//       "any.required": "Average mark is required",
//     }),
//     onDuty: Joi.boolean().messages({
//       "boolean.base": "onDuty must be a boolean value",
//     }),
//   }),
// };

// У цьому прикладі ми використовуємо метод .messages() для кожного правила в схемі, щоб задати власні повідомлення про помилки.

// Правило string.base стосується .string().
// Правило string.min стосується .min(), яке йде після .string().
// І так далі.

// Наприклад, якщо користувач надішле name як число, Joi поверне помилку з повідомленням:

// "Name must be a string"

// Таким чином, ми можемо гнучко налаштовувати повідомлення про помилки для кожного поля, роблячи їх більш зрозумілими та інформативними.

// To the next block
//!  Middleware валідації
// Middleware валідації

// celebrate — це middleware для Express, який обгортає Joi та спрощує валідацію в маршрутах. Він дозволяє перевіряти дані у різних частинах запиту: тіло (body), параметри (params), рядок запиту (query), заголовки (headers), кукі (cookies) тощо.

// Ви описуєте схему валідації (Joi schema) і вказуєте, до якої частини запиту її застосувати.
// celebrate виконує цю валідацію до контролера.
// Якщо дані валідні — запит переходить далі у контролер.
// Якщо ні — автоматично повертається помилка 400 Bad Request з поясненням, що саме не відповідає правилам.

// Використання схеми у маршруті

// Тепер підключимо схему у маршруті POST /students, щоб валідація виконувалась автоматично до контролера:

// // src/routes/studentsRoutes.js

// import { Router } from 'express';
// import { celebrate, Segments } from 'celebrate';
// import { createStudent } from '../controllers/studentsController.js';
// import { createStudentSchema } from '../validations/studentsValidation.js';

// const router = Router();

// router.post('/students', celebrate(createStudentSchema), createStudent);

// export default router;

// У цьому прикладі celebrate перевіряє тіло запиту за схемою createStudentSchema. Якщо дані некоректні — клієнт одразу отримає 400 Bad Request. Якщо все гаразд — виконається контролер createStudent.

// Як це працює

// У Express маршрут може мати не лише контролер, а й кілька проміжних функцій (middleware). Вони виконуються у тому порядку, в якому ми їх вказали.

// У прикладі вище:

// router.post('/students', celebrate(createStudentSchema), createStudent);

// Спочатку виконується celebrate. Він бере дані з req.body і перевіряє їх за схемою.
// Якщо дані невалідні — повертається помилка 400 Bad Request, і контролер не запускається.
// Якщо дані валідні — виконується наступна функція, тобто контролер createStudent.

// Таким чином, додавання celebrate другим аргументом у маршруті гарантує, що контролер працює лише з перевіреними даними.

// Middleware для обробки помилок

// Ми вже бачили, що celebrate автоматично генерує помилки при невдалій валідації (наприклад, якщо studentId має неправильний формат). Але щоб ці помилки правильно відображалися у нашому додатку, потрібно підключити спеціальний middleware errors() від celebrate.

// Де саме підключати?

// Усі middleware виконуються у порядку, в якому вони оголошені.
// Тому errors() має бути підключений до глобального errorHandler.
// Це потрібно для того, щоб спочатку відловлювались помилки валідації celebrate, а вже потім — усі інші.

// // src/server.js

// import express from "express";
// import "dotenv/config";
// import cors from "cors";
// // Імпортуємо middleware
// import { errors } from "celebrate";
// import { connectMongoDB } from "./db/connectMongoDB.js";
// import { logger } from "./middleware/logger.js";
// import { notFoundHandler } from "./middleware/notFoundHandler.js";
// import { errorHandler } from "./middleware/errorHandler.js";
// import studentsRoutes from "./routes/studentsRoutes.js";

// const app = express();
// const PORT = process.env.PORT ?? 3000;

// app.use(logger);
// app.use(express.json());
// app.use(cors());

// app.use(studentsRoutes);

// // обробка 404
// app.use(notFoundHandler);
// // обробка помилок від celebrate (валідація)
// app.use(errors());
// // глобальна обробка інших помилок
// app.use(errorHandler);

// await connectMongoDB();

// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// Якщо не підключити errors() від celebrate, то помилки валідації не будуть коректно оброблятися й ви отримаєте сирі Joi-помилки в консолі.

// Правильний порядок підключення гарантує, що:

// notFoundHandler ловить відсутні маршрути;
// errors() перехоплює проблеми з валідацією;
// errorHandler закриває все інше.

// Протестуємо як працює поточний код:

// To the next block
//! Валідація ідентифікатора
// Валідація ідентифікатора

// У MongoDB кожен документ має унікальний ідентифікатор у полі _id. Це ObjectId, який має строго визначений формат:

// завжди рядок у шістнадцятковому (hex) вигляді;
// довжина — рівно 24 символи (12 байт у двійковому представленні);
// автоматично генерується MongoDB при створенні документа.

// Через це будь-який довільний рядок (навіть із 24 символів) не обов’язково буде валідним ObjectId. Якщо такий рядок передати у запит, MongoDB може повернути помилку або просто не знайти документ.

// Щоб цього уникнути, ми додаємо валідацію ідентифікатора ще на рівні API. Це дозволяє:

// відсіювати некоректні або шкідливі запити;
// не передавати у базу "сміттєві" значення;
// одразу повертати зрозумілу помилку клієнту.

// Функція objectIdValidator

// Створимо кастомний валідатор для Joi, який перевірятиме значення на валідність ObjectId.

// // src/validations/studentsValidation.js

// import { Joi, Segments } from 'celebrate';
// import { isValidObjectId } from 'mongoose';

// // Кастомний валідатор для ObjectId
// const objectIdValidator = (value, helpers) => {
//   return !isValidObjectId(value) ? helpers.message('Invalid id format') : value;
// };

// // Схема для перевірки параметра studentId
// export const studentIdParamSchema = {
//   [Segments.PARAMS]: Joi.object({
//     studentId: Joi.string().custom(objectIdValidator).required(),
//   }),
// };

// isValidObjectId(value) — це утиліта з Mongoose, яка перевіряє, чи рядок відповідає формату MongoDB ObjectId.
// Якщо isValidObjectId повертає false, ми викликаємо helpers.message('Invalid id format'), щоб створити помилку в Joi.
// Якщо все гаразд, функція просто повертає значення далі.

// Таким чином, ми отримуємо зрозумілу помилку для клієнта замість технічної MongoDB-помилки.

// Використання у маршрутах

// Додамо схему у маршрут /students/:studentId, щоб celebrate автоматично перевіряв параметр studentId:

// // src/routes/studentsRoutes.js

// import { Router } from 'express';
// import { celebrate } from 'celebrate';

// import { getStudentById, deleteStudent } from '../controllers/studentsController.js';
// import { studentIdParamSchema } from '../validations/studentsValidation.js';

// const router = Router();

// router.get('/students/:studentId', celebrate(studentIdParamSchema), getStudentById);
// router.delete('/students/:studentId', celebrate(studentIdParamSchema), deleteStudent);

// export default router;

// Ми використовуємо одну й ту саму схему для обох маршрутів:

// GET /students/:studentId — отримання студента за id;
// DELETE /students/:studentId — видалення студента за id.

// Це дозволяє уникнути дублювання коду й зберігати валідацію в одному місці.

// Тепер:

// Якщо id валідний → виконується контролер.
// Якщо id невалідний → celebrate одразу повертає 400 Bad Request з повідомленням "Invalid id format".

// Простестуємо як працює валідація ідентифікатора:

//!  Валідація для PATCH
// Валідація для PATCH

// Тепер ми реалізуємо валідацію для маршруту PATCH /students/:studentId.

// У цьому випадку потрібно перевіряти дві речі:

// Ідентифікатор у параметрах маршруту. studentId має бути валідним ObjectId. Це дозволяє відсікти некоректні запити ще до звернення до бази.
// Тіло запиту. Оскільки це PATCH, усі поля є необов’язковими, але хоча б одне повинно бути передано. Для цього у Joi використовується .min(1).

// Створимо схему, яка перевірятиме одночасно і params, і body:

// // src/validations/studentsValidation.js

// import { Joi, Segments } from 'celebrate';
// import { isValidObjectId } from 'mongoose';

// // Кастомний валідатор для ObjectId
// const objectIdValidator = (value, helpers) => {
//   return !isValidObjectId(value) ? helpers.message('Invalid id format') : value;
// };

// export const updateStudentSchema = {
//   [Segments.PARAMS]: Joi.object({
//     studentId: Joi.string().custom(objectIdValidator).required(),
//   }),
//   [Segments.BODY]: Joi.object({
//     name: Joi.string().min(3).max(30),
//     age: Joi.number().integer().min(12).max(65),
//     gender: Joi.string().valid('male', 'female', 'other'),
//     avgMark: Joi.number().min(2).max(12),
//     onDuty: Joi.boolean(),
//   }).min(1), // важливо: не дозволяємо порожнє тіло
// };

// Тепер використаємо цю схему у маршруті PATCH /students/:studentId:

// // src/routes/studentsRoutes.js

// import { Router } from 'express';
// import { celebrate } from 'celebrate';
// import { updateStudent } from '../controllers/studentsController.js';
// import { updateStudentSchema } from '../validations/studentsValidation.js';

// const router = Router();

// router.patch('/students/:studentId', celebrate(updateStudentSchema), updateStudent);

// export default router;

// Якщо studentId невалідний → повертається 400 Bad Request з повідомленням "Invalid id format".
// Якщо тіло запиту порожнє → повертається 400 Bad Request з повідомленням від Joi.
// Якщо дані валідні → виконується контролер updateStudent.

// Протестуємо як працює валідація при оновленні інформації студента:

// To the next block
//!  Заняття 6. Пагінація та фільтрація
// Пагінація — це метод організації великої кількості даних, при якому записи відображаються частинами ("сторінками"), а не всі одразу.

// Замість того щоб завантажувати тисячі об’єктів за один запит, ми показуємо лише обмежену кількість записів, а користувач може переходити між сторінками.

// Навіщо потрібна пагінація?

// Полегшує навігацію: користувачеві простіше переглядати дані маленькими частинами.
// Зменшує навантаження: сервер віддає лише потрібну частину результатів, а не всю колекцію.
// Підвищує швидкість: на фронтенді працювати з 10–20 записами значно легше, ніж із кількома тисячами.

// Основні параметри пагінації

// При реалізації пагінації ми будемо працювати з такими властивостями:

// perPage — скільки записів показувати на одній сторінці;
// page — номер сторінки, яку хоче отримати користувач;
// totalItems — загальна кількість записів у колекції;
// totalPages — кількість сторінок, яка визначається як:

// Math.ceil(totalItems / perPage)

// Як це працює у запиті та відповіді

// Клієнт відправляє параметри page та perPage у запиті до бекенду.
// Бекенд повертає:
// список записів для потрібної сторінки;
// мета-інформацію: page, perPage, totalItems, totalPages.

// Таким чином, користувач завжди знає, скільки ще даних є та як між ними переміщатися.
//!  Створення пагінації
// Створення пагінації

// Додаємо пагінацію до маршруту отримання всіх студентів GET /students. Ми очікуємо, що клієнт може передати у рядку запиту параметри page та perPage.

// /students?page=1&perPage=15

// Це означає: "поверни мені першу сторінку з 15 студентів".

// Валідація параметрів

// Щоб запити були коректними, одразу додамо валідацію через Joi і celebrate. Для валідації параметрів рядка запиту описуємо схему в Segments.QUERY.

// // src/validations/studentsValidation.js

// import { Joi, Segments } from "celebrate";

// export const getStudentsSchema = {
//   [Segments.QUERY]: Joi.object({
//     page: Joi.number().integer().min(1).default(1),
//     perPage: Joi.number().integer().min(5).max(20).default(10),
//   }),
// };

// Що тут відбувається:

// page — має бути цілим числом, не менше ніж 1. Якщо клієнт не передав значення, воно автоматично дорівнює 1.
// perPage — кількість студентів на сторінці. Має бути від 5 до 20. Якщо клієнт не вказав, за замовчуванням буде 10.
// Обидва параметри необов’язкові: якщо їх немає в запиті, ми все одно отримаємо безпечні дефолтні значення.

// Додаємо middleware валідації до маршруту:

// // src/routes/studentsRoutes.js

// import { getStudentsSchema } from "../validations/studentsValidation.js";

// router.get("/students", celebrate(getStudentsSchema), getStudents);

// Контролер із логікою пагінації

// Тепер оновимо контролер getStudents, щоб він віддавав студентів частинами.

// //src/controllers/studentsController.js

// import { Student } from "../models/student.js";

// export const getStudents = async (req, res) => {
// 	// Отримуємо пара метри пагінації
//   const { page = 1, perPage = 10 } = req.query;

//   const skip = (page - 1) * perPage;

//   // Створюємо базовий запит до колекції
//   const studentsQuery = Student.find();

//   // Виконуємо одразу два запити паралельно
//   const [totalItems, students] = await Promise.all([
//     studentsQuery.clone().countDocuments(),
//     studentsQuery.skip(skip).limit(perPage),
//   ]);

// 	// Обчислюємо загальну кількість «сторінок»
//   const totalPages = Math.ceil(totalItems / perPage);

//   res.status(200).json({
//     page,
//     perPage,
//     totalItems,
//     totalPages,
//     students,
//   });
// };

// У відповіді ми віддаємо не тільки список студентів, але й корисну мета-інформацію:

// на якій сторінці він зараз,
// скільки студентів показано на сторінці,
// скільки студентів є загалом,
// скільки всього сторінок доступно.

// Розбір коду крок за кроком

// 1. Обчислюємо skip

// const skip = (page - 1) * perPage;

// Це визначає, скільки записів потрібно пропустити перед тим, як відібрати дані для поточної сторінки:

// якщо page = 1 → пропускаємо 0 записів;
// якщо page = 2 → пропускаємо perPage записів;
// якщо page = 3 → пропускаємо 2 * perPage записів.
// Таким чином ми зсуваємося на потрібну сторінку.

// 2. Створюємо базовий запит

// const studentsQuery = Student.find();

// Тут ми ще не звертаємось до бази, а лише описуємо запит. Це дозволяє згодом «доповнювати» його іншими методами (skip, limit тощо).

// 3. Виконуємо запити паралельно

// const [totalItems, students] = await Promise.all([
//   studentsQuery.clone().countDocuments(),
//   studentsQuery.skip(skip).limit(perPage),
// ]);

// .countDocuments() — підраховує загальну кількість студентів у колекції.
// .skip(skip).limit(perPage) — повертає тільки ту частину студентів, яка відповідає потрібній сторінці.

// Ми запускаємо обидва запити одночасно за допомогою Promise.all. Це економить час, бо замість того, щоб чекати спочатку на один, а потім на інший — вони виконуються паралельно.

// 4. Чому потрібен .clone()

// У Mongoose один і той самий запит не можна виконати двічі. Тому перед повторним використанням його потрібно «клонувати». У нашому випадку це потрібно, щоб один раз отримати кількість документів, а другий — самі документи.

// 5. Обчислюємо кількість сторінок

// const totalPages = Math.ceil(totalItems / perPage);

// Наприклад, якщо в колекції є 53 студенти, а на сторінку ми показуємо по 10, отримаємо:

// Math.ceil(53 / 10) = 6

// Тобто дані займають 6 сторінок.

// Пропонуємо подивитися на пагінацію в дії:

// To the next block

//! Фільтрація
// Фільтрація

// Коли ми працюємо з великими наборами даних, важливо мати можливість отримувати не всі документи одразу, а лише ті, які відповідають певним умовам. Це і є фільтрація.

// Фільтрація дозволяє:

// обмежувати результати запитів;
// працювати тільки з потрібними даними;
// оптимізувати роботу сервера й бази даних.

// Як клієнт передає фільтри

// Найпоширеніший спосіб — через query parameters в URL.

// https://example.com/students?minAge=12&maxAvgMark=10

// символ ? відділяє шлях (/students) від параметрів;
// параметри передаються у вигляді ключ=значення;
// кілька параметрів розділяються знаком &.

// У цьому прикладі:

// minAge=12 означає, що мінімальний вік студента має бути 12 років;
// maxAvgMark=10 означає, що середній бал не повинен перевищувати 10.

// Фільтрацію варто виконувати саме на рівні бази даних, тобто на бекенді, а не після отримання всіх даних на фронтенді . Це швидше та ефективніше.

// Фільтрація в MongoDB

// У MongoDB ми можемо накладати умови за допомогою спеціальних операторів.

// Приклад: знайти студентів, у яких середній бал від 10 і вище:

// db.students.find({ avgMark: { $gte: 10 } });

// Тут $gte означає greater than or equal (більше або дорівнює).

// Основні оператори в Mongoose

// У Mongoose ці оператори працюють так само. Ось кілька прикладів:

// 1. Рівність ($eq)

// Student.find({ age: { $eq: 9 } });

// Знаходимо студентів з віком 9.

// 2. Нерівність ($ne)

// Student.find({ avgMark: { $ne: 10 } });

// Знаходимо студентів, у яких середній бал не дорівнює 10.

// 3. Більше ($gt), Більше або дорівнює ($gte)

// Student.find({ age: { $gt: 8 } });

// Знаходимо студентів з віком більше 8.

// 4. Менше ($lt), Менше або дорівнює ($lte)

// Student.find({ avgMark: { $lte: 8.5 } });

// Знаходимо студентів із середнім балом не вищим за 8.5.

// 5. У межах списку ($in)

// Student.find({ gender: { $in: ['male', 'female'] } });

// Знаходимо студентів чоловічої або жіночої статі.

// 6. Не у списку ($nin)

// Student.find({ gender: { $nin: ['male'] } });

// Знаходимо всіх студентів, крім чоловіків.

// Query Builder у Mongoose

// У Mongoose є зручний механізм побудови складних запитів — Query Builder. Він дозволяє будувати умови покроково, додаючи фільтри «ланцюжком».

// Приклад:

// await Student.find()
//   .where('age').gte(6).lte(10)   // вік від 6 до 10 включно
//   .where('avgMark').gt(7)        // середній бал більше 7
//   .exec();

// Що тут відбувається:

// .where('age').gte(6).lte(10) → додаємо умову для віку;
// .where('avgMark').gt(7) → додаємо умову для середнього балу;
// .exec() → виконує зібраний запит.

// Таким чином, ми отримаємо студентів, яким від 6 до 10 років, і які мають середній бал вище 7.

// Завдяки фільтрації ми можемо швидко працювати навіть із великими колекціями, отримуючи лише ті дані, які нам потрібні.

// To the next block

//! Створення фільтрів
// Створення фільтрів

// Додамо можливість фільтрувати колекцію студентів за статтю (gender) та мінімальним значенням середнього балу (minAvgMark).

// Приклад запиту з усіма параметрами:

// /students?page=1&perPage=15&gender=female&minAvgMark=2

// Схема валідації

// Спочатку оновимо схему, щоб перевіряти всі можливі query-параметри у маршруті GET /students.

// // src/validations/studentsValidation.js

// import { Joi, Segments } from "celebrate";

// export const getStudentsSchema = {
//   [Segments.QUERY]: Joi.object({
//     page: Joi.number().integer().min(1).default(1),
//     perPage: Joi.number().integer().min(5).max(20).default(10),
//     gender: Joi.string().valid("male", "female", "other"),
//     minAvgMark: Joi.number().positive()
//   })
// };

// page і perPage — як і раніше, для пагінації;
// gender — дозволені значення "male", "female", "other";
// minAvgMark — число більше нуля, для вибору студентів із середнім балом вище заданого.

// Контролер

// Тепер у контролері будуємо запит динамічно, враховуючи, які параметри передав користувач.

// Модифікуємо код контролера:

// // src/controllers/studentsController.js

// export const getStudents = async (req, res) => {
//   const { page = 1, perPage = 10, gender, minAvgMark } = req.query;
//   const skip = (page - 1) * perPage;

//   const studentsQuery = Student.find();

//   // Будуємо фільтр
//   if (gender) {
//     studentsQuery.where("gender").equals(gender);
//   }
//   if (minAvgMark) {
//     studentsQuery.where("avgMark").gte(minAvgMark);
//   }

//   const [totalItems, students] = await Promise.all([
//     studentsQuery.clone().countDocuments(),
//     studentsQuery.skip(skip).limit(perPage),
//   ]);

//   const totalPages = Math.ceil(totalItems / perPage);

//   res.status(200).json({
//     page,
//     perPage,
//     totalItems,
//     totalPages,
//     students,
//   });
// };

// Що тут відбувається?

// studentsQuery.where("gender").equals(gender) — додає умову для фільтрації за статтю, якщо параметр переданий.
// studentsQuery.where("avgMark").gte(minAvgMark) — додає умову для фільтрації за середнім балом (беремо тільки тих, у кого avgMark ≥ minAvgMark).
// Promise.all([...]) — запускаємо підрахунок (countDocuments) і отримання списку студентів одночасно, щоб не робити два послідовних запити.
// .clone() — потрібен у Mongoose, щоб один і той самий запит можна було виконати двічі (для підрахунку і для вибірки).

// У результаті ми отримуємо список студентів із врахуванням пагінації та фільтрів, а також додаткову інформацію: скільки всього студентів (totalItems) і скільки сторінок (totalPages).

// Давайте тепер подивимось на пагінацію, фільтра та сортування разом:

// To the next block
