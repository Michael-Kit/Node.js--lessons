//! Заняття 1. Вступ до Node.js
// Що таке Node.js

// Node.js — це середовище виконання JavaScript поза браузером.

// У браузері JavaScript керує DOM і роботою інтерфейсу.Node.js же дозволяє запускати цей код на комп’ютері чи сервері, відкриваючи
// шлях до створення бекенд - застосунків.

// Його основа — движок V8 (той самий, що використовується у Google Chrome). Саме завдяки цьому Node.js швидкий і ефективний.

// Де використовується Node.js

// Node.js часто застосовують для:

// Веб-серверів і API — щоб фронтенд отримував дані з бекенду.
// Чатів та інших real-time застосунків — де важлива миттєва реакція (наприклад, повідомлення без перезавантаження сторінки).
// Прототипів і невеликих проєктів — коли треба швидко зробити робочий бекенд.
// Інструментів для фронтенду — більшість сучасних збирачів (webpack, vite) працюють на Node.js.

// Ключова перевага для вас як початківців: ви вже знаєте JavaScript з фронтенду → з Node.js можна використовувати ті самі знання
// для створення бекенду.

// Як працює Node.js

// Node.js побудований на принципі асинхронного вводу/виводу (non-blocking I/O).

// Це означає, що він може обробляти сотні й тисячі запитів одночасно, не блокуючись на одному з них.

// Приклад: коли сервер читає файл з диска, він делегує цю операцію файловій системі і в цей час може обробляти інші запити.

// Завдяки цьому Node.js дуже ефективний для додатків, які потребують великої кількості одночасних підключень (чати, API, стрімінги).

// Переваги Node.js

// Асинхронність
// Не блокує виконання, поки чекає результат від бази даних чи файлової системи.
// Одна мова на фронті та бекенді
// Той самий JavaScript можна використовувати і для клієнтської частини, і для серверної.Це зручно для команд і дозволяє швидше
// розробляти проєкти.
// Кросплатформеність
// Node.js працює на Windows, Linux, macOS і навіть вбудованих системах.
// Швидкість
// Написаний на C++ і працює на V8. Дозволяє створювати розширення (N-API) і підтримує багатопоточність у внутрішніх операціях.

// Обмеження Node.js

// Node.js не підходить для задач із великим навантаженням на процесор:

// складні математичні обчислення,
// рендеринг зображень,
// обробка відео чи аудіо “всередині” сервера.
// Тут краще використовувати інші мови (C++, Go, Rust).

//!    Ініціалізація Node.js-проєкта

// Для створення проєкта необхідно переконатися, що на вашому комп’ютері встановлено Node.js.Для цього введіть у терміналі
// команду для перевірки його версії:

// node --version

// Якщо у терміналі ви побачите щось на кшталт v18.17.0(або новішу версію), значить Node.js уже встановлено.Якщо ж отримаєте
// відповідь command not found: node, тоді потрібно завантажити та встановити LTS - версію з офіційного сайту.

// Для роботи з Node.js-застосунками використовується npm — менеджер пакетів.

// У терміналі створіть папку проєкта з будь-якою назвою:

// mkdir nodejs-app

// Перейдіть у створену папку:

// cd nodejs-app

// Ініціалізуйте npm:

// npm init -y

// Дивись відео в папкі Node за такою назвою:

// 1. Модуль 1. Основи Node.js - Ініціалізація Node.js-проєкта

// З’явиться файл package.json із базовою інформацією про проєкт.Додамо сучасний режим ESM(щоб можна було використовувати
//   import/export), додавши властивість "type": "module".

// {
//   "name": "nodejs-app",
//   "version": "1.0.0",
//   "description": "",
//   "main": "src/index.js",
//   // Додали нову властивість type
//   "type":"module",
//   "scripts": {
//     "test": "echo \\"Error: no test specified\\" && exit 1"
//   },
//   "keywords": [],
//   "author": "",
//   "license": "ISC"
// }

//!   Виконання JS поза браузером

// Створимо папку src, де зберігатиметься весь код, і додамо у ній перший файл index.js з таким вмістом:

// // src/index.js

// const message = 'Hello world';

// console.log(message);

// JavaScript-код можна виконати за допомогою команди node, вказавши після неї шлях до файлу, який потрібно запустити:

// node src/index.js

// У терміналі побачимо результат:

// Hello world
// Дивсь відео в папкі Node-Відео до конспекту за такою назвою:

// 2. Модуль 1. Основи Node.js - Виконання JS поза браузером-1

// Nodemon

// Незручно щоразу після змін у коді вручну запускати JavaScript - файл або сервер, щоб перевірити результат.Щоб автоматизувати
// цей процес, використаємо пакет nodemon, який автоматично перезапускає застосунок після змін у файлах.

// Встановіть його як залежність для розробки командою:

// npm install -D nodemon

// Додайте скрипт у файл package.json:

// // package.json

// {
//   "scripts": {
//     "dev": "nodemon src/index.js"
//   }
// }

// Тепер ви можете запускати застосунок за допомогою команди:

// npm run dev

// При збереженні змін у JavaScript-файлах він буде автоматично перезапускатися.
// Дивсь відео в папкі Node-Відео до конспекту за такою назвою:

// 3. Модуль 1. Основи Node.js - Виконання JS поза браузером-2

//!  Налаштування робочого середовища

// Додайте в кореневу папку проєкта конфігураційні файли та встановіть відповідні розширення для VSCode.

// EditorConfig

// Встановіть розширення EditorConfig та створіть файл.editorconfig.Він забезпечує однакові відступи, кодування й кінцівки
// рядків у різних редакторах.Такі налаштування допомагають уникнути проблем, пов’язаних із різницею символів кінця рядка між
// різними операційними системами.

// root = true

// [*]
// charset = utf-8
// end_of_line = lf
// insert_final_newline = true
// indent_style = space
// indent_size = 2
// trim_trailing_whitespace = true

// //? Prettier

// Встановіть розширення Prettier та додайте файл .prettierrc, у якому зберігатимуться налаштування для форматування коду.

// {
//   "semi": true,
//   "singleQuote": true,
//   "trailingComma": "all",
//   "printWidth": 80,
//   "tabWidth": 2,
//   "useTabs": false,
//   "arrowParens": "always",
//   "bracketSpacing": true,
//   "endOfLine": "lf"
// }

// //?  ESLint

// Лінтинг коду відповідно до стандарту — важлива складова кожного проєкта. Він дозволяє задати єдиний стиль написання коду для всієї команди та контролювати дотримання певних кращих практик.

// Для роботи з ESLint у VS Code потрібно встановити розширення ESLint.

// У наступному відео розглянемо етапи ініціалізації ESLint у проєкті командою:

// Подивсь відео в папкі Node - Відео до конспекту за такою назвою:
// "4. Модуль 1. Основи Node.js - Налаштування робочого середовища"

// npm init @eslint/config@latest

// Замініть вміст свого файлу eslint.config.mjs наступним кодом. Ми трохи його доповнили під наші потреби, додавши властивість rules.

// import js from "@eslint/js";
// import globals from "globals";
// import { defineConfig } from "eslint/config";

// export default defineConfig([
//   {
//     files: ["**/*.{js,mjs,cjs}"],
//     plugins: { js },
//     extends: ["js/recommended"],
//     languageOptions: { globals: globals.node },
//     rules: {
//       semi: "error",
//       "no-unused-vars": ["error", { args: "none" }],
//       "no-undef": "error",
//     },
//   },
// ]);

// //?  GitIgnore

// Файл .gitignore використовується для вказання файлів і папок, які не повинні потрапляти в репозиторій Git.

// .vscode
// .DS_Store
// .idea

// # Logs
// logs
// *.log
// npm-debug.log*
// yarn-debug.log*
// yarn-error.log*
// lerna-debug.log*

// # Diagnostic reports (https://nodejs.org/api/report.html)
// report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

// # Runtime data
// pids
// *.pid
// *.seed
// *.pid.lock

// # Directory for instrumented libs generated by jscoverage/JSCover
// lib-cov

// # Coverage directory used by tools like istanbul
// coverage
// *.lcov

// # nyc test coverage
// .nyc_output

// # Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
// .grunt

// # Bower dependency directory (https://bower.io/)
// bower_components

// # node-waf configuration
// .lock-wscript

// # Compiled binary addons (https://nodejs.org/api/addons.html)
// build/Release

// # Dependency directories
// node_modules/
// jspm_packages/

// # Snowpack dependency directory (https://snowpack.dev/)
// web_modules/

// # TypeScript cache
// *.tsbuildinfo

// # Optional npm cache directory
// .npm

// # Optional eslint cache
// .eslintcache

// # Optional stylelint cache
// .stylelintcache

// # Optional REPL history
// .node_repl_history

// # Output of 'npm pack'
// *.tgz

// # Yarn Integrity file
// .yarn-integrity

// # dotenv environment variable files
// .env
// .env.*
// !.env.example

// # parcel-bundler cache (https://parceljs.org/)
// .cache
// .parcel-cache

// # Next.js build output
// .next
// out

// # Nuxt.js build / generate output
// .nuxt
// dist

// # Gatsby files
// .cache/
// # Comment in the public line in if your project uses Gatsby and not Next.js
// # https://nextjs.org/blog/next-9-1#public-directory-support
// # public

// # vuepress build output
// .vuepress/dist

// # vuepress v2.x temp and cache directory
// .temp
// .cache

// # Sveltekit cache directory
// .svelte-kit/

// # vitepress build output
// **/.vitepress/dist

// # vitepress cache directory
// **/.vitepress/cache

// # Docusaurus cache and generated files
// .docusaurus

// # Serverless directories
// .serverless/

// # FuseBox cache
// .fusebox/

// # DynamoDB Local files
// .dynamodb/

// # Firebase cache directory
// .firebase/

// # TernJS port file
// .tern-port

// # Stores VSCode versions used for testing VSCode extensions
// .vscode-test

// # yarn v3
// .pnp.*
// .yarn/*
// !.yarn/patches
// !.yarn/plugins
// !.yarn/releases
// !.yarn/sdks
// !.yarn/versions

// # Vite logs files
// vite.config.js.timestamp-*
// vite.config.ts.timestamp-*

//!   Вбудовані модулі Node.js

// У Node.js є набір вбудованих модулів, які доступні відразу без встановлення додаткових пакетів. Наприклад:

// node:os — інформація про операційну систему;
// node:http — створення веб-серверів;
// node:path — робота зі шляхами до файлів і папок;
// node:fs — робота з файловою системою.

// У цьому розділі ми базово розглянемо роботу з файловою системою та формування шляхів.

// Модуль path

// Модуль node:path допомагає працювати з файловими шляхами у різних операційних системах.

// У Windows для побудови шляхів використовується роздільник \\, а у POSIX-системах (Linux, macOS) — /.

// Щоб уникнути проблем із цими відмінностями, у Node.js варто використовувати методи модуля path, а не писати шляхи вручну.

// Важливо! Модуль path не перевіряє, чи існує файл або папка. Він тільки допомагає правильно формувати шляхи.

// path.join(...paths)

// Об’єднує частини шляху у правильний формат для поточної ОС.

// import path from "node:path";

// const somePath = path.join("some_folder", "some_file.txt");
// // на macOS → 'some_folder/some_file.txt'
// // на Windows → 'some_folder\\\\some_file.txt'

// Можна вкладати виклики, щоб будувати складніші шляхи:

// import path from "node:path";

// // абсолютний шлях до робочої директорії
// const pathToWorkDir = path.join(process.cwd());

// // додаємо нові частини до шляху
// const pathToFile = path.join(pathToWorkDir, "some_folder", "some_file.txt");

// // macOS → /коренева_папка/some_folder/some_file.txt
// // Windows → C:\\\\коренева_папка\\\\some_folder\\\\some_file.txt

// Тут ми використали глобальну змінну process, а метод process.cwd() повертає абсолютний шлях до папки, з якої запущений процес Node.js.

// path.parse(path)

// Розбирає рядок-шлях на складові частини:

// import path from "node:path";

// // macOS
// console.log(path.parse("/home/user/dir/file.txt"));
// /*
// {
//   root: '/',
//   dir: '/home/user/dir',
//   base: 'file.txt',
//   ext: '.txt',
//   name: 'file'
// }
// */

// // Windows
// console.log(path.parse("C:\\\\path\\\\dir\\\\file.txt"));
// /*
// {
//   root: 'C:\\\\',
//   dir: 'C:\\\\path\\\\dir',
//   base: 'file.txt',
//   ext: '.txt',
//   name: 'file'
// }
// */

// За потреби більше методів можна знайти у документації Node.js, але основні, які нам потрібні, ми вже розглянули.

// Модуль fs

// Одна з головних можливостей Node.js — робота з файлами та папками. Для цього використовується вбудований модуль fs.

// Багато його методів існують у двох варіантах:

// синхронні (readFileSync, writeFileSync), які блокують виконання коду;
// асинхронні (через fs/promises), які працюють із Promise і не блокують.

// Синхронні методи іноді зручно застосувати, наприклад, щоб один раз зчитати конфігурацію на старті програми.
// У більшості випадків краще використовувати асинхронні версії.

// Читання файлу

// fs.readFileSync(path, options) — синхронне читання вмісту файла.Приймає шлях до файлу та, за потреби,
//   кодування("utf8", "ascii" тощо).Якщо кодування не вказано, повертає Buffer, якщо вказано — звичайний рядок.

// import fs from "node:fs";

// // приклад без кодування
// const buffer = fs.readFileSync("file.txt");
// console.log(buffer); // <Buffer 48 65 6c 6c 6f ...>

// // приклад із кодуванням
// const data = fs.readFileSync("file.txt", "utf8");
// console.log("Вміст файлу:", data); // "Hello"

// fs.readFile(path, options) — асинхронне читання вмісту файла. Приймає шлях і опції. Повертає Promise, який у разі успіху містить або Buffer, або рядок (залежно від того, чи вказано кодування).

// import fs from "node:fs/promises";

// // без кодування
// const buffer = await fs.readFile("file.txt");
// console.log(buffer); // <Buffer ... >

// // з кодуванням
// const data = await fs.readFile("file.txt", "utf8");
// console.log("Вміст файлу:", data); // "Hello"

// У Node.js Buffer — це спеціальний тип даних для зберігання двійкової інформації(наприклад, вмісту файлів).Якщо потрібно
// працювати з текстом, достатньо вказати кодування, і тоді результатом буде звичайний рядок.

// Запис у файл

// fs.writeFileSync(path, data, options) — синхронний запис у файл. Якщо файл існує — перезапише його, якщо ні — створить новий.

// import fs from "node:fs";

// fs.writeFileSync("output.txt", "Привіт з Node.js!", "utf8");

// fs.writeFile(path, data, options) — асинхронний запис у файл. Повертає Promise, що виконується після завершення операції.

// import fs from "node:fs/promises";

// await fs.writeFile("output.txt", "Привіт з Node.js!", "utf8");
// console.log("Дані успішно записані у файл.");

// Додавання у файл

// fs.appendFile(path, data, options) — асинхронне додавання у файл. Дописує дані в кінець файлу.

// import fs from "node:fs/promises";

// await fs.appendFile("output.txt", "\\nЩе один рядок", "utf8");
// console.log("Дані успішно додані у файл.");

// Перейменування / переміщення файлів

// fs.rename(oldPath, newPath) — асинхронне перейменування або переміщення файлу. Повертає Promise.

// import fs from "node:fs/promises";

// await fs.rename("oldfile.txt", "newfile.txt");
// console.log("Файл успішно перейменовано.");

// Видалення файлу

// fs.unlink(path) — асинхронне видалення файлу. Повертає Promise.

// import fs from "node:fs/promises";

// await fs.unlink("file.txt");
// console.log("Файл успішно видалено.");

// Підсумок

// path — для правильного формування шляхів у різних ОС.
// fs — для роботи з файлами та папками.
// Синхронні методи зручні для одноразових операцій (наприклад, читання конфігів на старті).
// В реальних застосунках використовуємо асинхронні методи (fs/promises), бо вони не блокують виконання.

// Ці два модулі є базовими інструментами у Node.js, і розуміння їхньої роботи — перший крок до створення повноцінних серверних застосунків.

//!  Тип даних Buffer

// При роботі з файловою системою ви часто будете бачити об’єкти типу Buffer. Це спеціальний тип даних у Node.js, призначений для роботи з двійковими даними.

// Біт — це найменша одиниця інформації: 0 або 1.
// Байт — це 8 бітів. У такій комбінації можна представити 256 різних значень.

// Buffer у Node.js — це масив байтів. Кожен байт може зберігати невелике значення (наприклад, код символу).

// import fs from "node:fs/promises";

// const buffer = await fs.readFile("hello.txt");
// // якщо у файлі hello.txt був текст "Hello World!"

// console.log(buffer);
// // <Buffer 48 65 6c 6c 6f 20 57 6f 72 6c 64 21>

// Вивід <Buffer ...> показує набір байтів у шістнадцятковій системі (hex). Кожен байт відповідає одному символу або службовому знаку (наприклад, пробілу).

// Кодування

// Файл завжди зберігається як набір байтів. Але щоб інтерпретувати його вміст як текст, потрібно знати кодування.

// Найпоширеніше текстове кодування — UTF-8. Саме воно дозволяє перетворити байти у символи:

// import fs from "node:fs/promises";

// const buffer = await fs.readFile("hello.txt");
// console.log(buffer.toString("utf-8")); // Hello World!

// Якщо при читанні файлу одразу вказати кодування("utf8"), результатом буде рядок, а не Buffer.Якщо кодування не
// вказано — повертається Buffer.

// Висновок

// Buffer — це масив байтів.
// Якщо методи fs.readFile/fs.readFileSync викликати без кодування, результатом буде Buffer.
// Якщо вказати кодування ("utf8"), результатом буде звичайний рядок.
// Розуміння Buffer стане в пригоді при завантаженні файлів та роботі з двійковими даними (наприклад, зображеннями).

//!  Фронтенд та бекенд

// Вебзастосунок складається з двох основних частин: фронтенду та бекенду.

//   Фронтенд — це все, що бачить і з чим взаємодіє користувач: вебсторінка, кнопки, форми, стилі.Він працює у браузері та написаний
// здебільшого на HTML, CSS, JavaScript(або фреймворках на їх основі — React, Vue, Angular).
//   Бекенд — це серверна частина.Вона отримує запити від фронтенду, обробляє їх і повертає відповіді.Користувач її безпосередньо
// не бачить, але без бекенду неможливий жоден сучасний вебсервіс.

// З чого складається бекенд

// У більшості випадків бекенд включає два головні компоненти:

// Вебсервер – програма, яка приймає HTTP - запити від клієнтів(браузерів, мобільних застосунків) і повертає HTTP - відповіді.
//  У Node.js для цього часто використовують Express.js.
// База даних – система зберігання інформації.Уявіть інтернет - магазин: дані про товари, користувачів, замовлення
// зберігаються в базі даних, а бекенд отримує їх і відправляє клієнту.Приклади: MongoDB, PostgreSQL, MySQL.

// Додатково бекенд може включати:

// Авторизацію та автентифікацію (керування доступом користувачів).
// Файлове сховище (наприклад, для зображень чи документів).
// Зовнішні інтеграції (платіжні системи, сторонні API).
// Логіку бізнес-процесів (наприклад, розрахунок вартості замовлення або перевірка доступності товару).

// Як це працює
// Користувач у браузері натискає кнопку → фронтенд відправляє HTTP-запит на сервер.
// Вебсервер приймає цей запит і вирішує, що з ним робити: звернутися до бази даних, виконати бізнес - логіку, віддати файл чи
// повідомлення про помилку.
// Сервер формує відповідь і надсилає її назад фронтенду.
// Фронтенд показує результат користувачу.

//!  REST API

// Перш ніж писати власний бекенд і працювати з HTTP - запитами в Node.js, нагадаємо, що таке REST API.Ви вже користувалися ним у
// фронтенді, коли отримували чи відправляли дані на сервер.

// REST (Representational State Transfer) API — це спосіб побудови вебсервісів, який визначає, як клієнт і сервер взаємодіють через Інтернет.

// Простіше кажучи: REST API описує правила, за якими клієнт (наприклад, браузер) може попросити дані у сервера або надіслати йому нові.

// Уявіть, що сервер — це поштове відділення, а REST API — це правила, як саме ми можемо відправляти і отримувати листи чи пакунки.

// Ресурси

// Ресурс — це сутність, з якою працює сервер.

// У поштовому відділенні ресурсом є лист або посилка.
// У бібліотеці — книга.
// В університеті — студент.
// Наприклад, ресурс «студент» може виглядати так:

// {
//   "id": 123,
//   "name": "John Doe",
//   "age": 16,
//   "gender": "male",
//   "onDuty": false
// }

// Методи запиту

// Метод — це дія, яку клієнт хоче виконати над ресурсом.

// У поштовому відділенні ви можете отримати лист, відправити пакунок чи змінити адресу. У REST API діють схожі принципи:

// GET — отримати ресурс (наприклад, список студентів).
// POST — створити новий ресурс.
// PUT — повністю оновити ресурс або створити новий.
// PATCH — частково оновити ресурс.
//   DELETE — видалити ресурс.

// Шляхи (роути)

// Щоб знайти ресурс, потрібна його адреса. У REST API це URL.

// https://example.com/students — усі студенти.
// https://example.com/students/123 — студент із id=123.
// https://example.com/students/123/homeworks — усі домашні роботи студента №123.

// Зверніть увагу: назви сутностей пишемо у множині(students, homeworks).Частина 123 — це динамічний параметр, який
// можна замінити іншим id.

// Параметри запиту

// Іноді потрібно уточнити результат: відсортувати чи відфільтрувати дані.Для цього використовують query parameters
// (параметри запиту).Вони пишуться після ? у URL.

// Приклад:

// https://example.com/students?order=asc&search=joe&page=1&per_page=10

// Такий запит може повернути перших 10 студентів, відсортованих у порядку зростання, чиї імена містять «joe».

// Приклади REST-запитів

// Отримати всіх студентів:

// GET https://example.com/students

// Оновити дані студента з id=123:

// PATCH https://example.com/students/123

// Видалити домашнє завдання з id=456 у студента №123:

// DELETE https://example.com/students/123/homeworks/456

// Короткий підсумок

// REST API — це набір правил, як клієнт може звертатися до сервера за допомогою HTTP-запитів.

// Він визначає:

// які є ресурси,
// які дії можна над ними виконувати (методи),
// які адреси мають ці ресурси (шляхи),
// як уточнювати запит (параметри).
// Це схоже на поштову систему: у вас є адреса (URL), спосіб доставки (метод) і сам вміст (ресурс).

// Перегляньте запит

// GET https://api.example.com/books?genre=fiction&author=John+Doe

// // todo
// Виберіть найкраще тлумачення такого запиту:

// отримати книгу з id fiction, автор якої будь-хто, окрім John Doe
// видалити книгу із жанром fiction та автором John Doe
// + отримати всі книги, жанр яких — fiction, а автор — John Doe
// створити нову книгу із жанром fiction та автором John Doe
// Result

// The answer is correct

//!  Postman

// Щоб перевіряти, як працює ваш бекенд, потрібні інструменти для тестування HTTP-запитів.

// Ми будемо користуватися Postman, бо він має все необхідне для роботи з API: можна створювати запити, відправляти їх
// на сервер, перевіряти відповіді й навіть документувати API.

// Postman — це програма для тестування та розробки API з простим і зручним інтерфейсом.

// Можливості Postman

// Надсилання HTTP-запитів — легко створювати GET, POST, PUT, PATCH, DELETE та інші запити.
// Тестування API — можна писати прості тести на JavaScript для перевірки роботи вашого коду.
// Організація запитів — усі запити зручно зберігати у колекціях.
// Зразки даних — можна зберігати типові JSON-об’єкти для швидкого тестування.
// Документація API — Postman автоматично генерує документацію на основі ваших колекцій.

// Postman можна встановити на Windows, macOS, Linux або як розширення для браузера. Завантаження: postman.com/downloads.

// Дивись відео з папкм Node - назвою: Postman

// Радимо активно тренуватися з Postman! Для цього можна використати безкоштовний тестовий бекенд — JSONPlaceholder.
// Це чудовий спосіб відправляти реальні HTTP - запити й бачити відповіді у форматі JSON.

//!  Заняття 2. Знайомство з

// Express — мінімалістичний веб-фреймворк для Node.js. Він спрощує створення HTTP-серверів та REST API:

// маршрутизація (обробка шляхів і методів HTTP);
// конвеєр middleware (до/після обробки запиту);
// зручні методи відповіді (res.json, res.status тощо).
// Express не нав’язує ORM, шаблонізатори чи архітектуру — ці речі додаєш за потреби.

// Створення вебсервісу

// Встанови пакет:

// npm install express

// Мінімальний застосунок (app boilerplate) — файл src/server.js:

// // src/server.js
// import express from 'express';

// const app = express();
// const PORT = 3000;

// // Перший маршрут
// app.get('/', (req, res) => {
//   res.status(200).json({ message: 'Hello world!' });
// });

// // Запуск сервера
// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// Порт — номер “входу” для мережевих з’єднань твоєї програми (тут 3000). Усі запити на цей порт обробляє твій сервер.

// Онови скрипт запуску в package.json:

// // package.json

// {
//   "scripts": {
//     "dev": "nodemon src/server.js"
//   }
// }

// Запусти у dev-режимі (ми вже налаштували nodemon у попередньому занятті):

// npm run dev

// Перейди в браузері або зроби GET запит у POSTMAN на http://localhost:3000 — побачиш JSON-відповідь.

// Маршрути та обробники

// У вебсервері важливо вміти реагувати на різні шляхи (routes) та HTTP-методи. Для цього в Express використовуються методи об’єкта app.

// Кожен маршрут складається з:

// HTTP-методу (GET, POST, PUT, PATCH, DELETE).
// Шляху (наприклад, /, /users, /products/:id).
// Функції-обробника (callback) — виконується щоразу, коли сервер отримує запит, що підходить під метод і шлях.

// Функція-обробник завжди має два аргументи:

// req (request) — об’єкт запиту. Містить інформацію про сам HTTP-запит: шлях, параметри, тіло, заголовки.
// res (response) — об’єкт відповіді. Використовується для формування і відправки відповіді клієнту.

// Перший маршрут:

// // GET-запит до кореневого маршруту "/"
// app.get('/', (req, res) => {
//   res.status(200).json({
//     message: 'Hello world!',
//   });
// });

// Що тут відбувається:

// app.get — ми реєструємо маршрут для GET-запитів.
// '/' — шлях. Це означає, що маршрут спрацює при запиті до http://localhost:3000/.
// (req, res) => { ... } — функція-обробник. Вона виконається автоматично, коли на сервер прийде GET-запит до цього шляху.
// res.status(200) — встановлюємо код відповіді 200 OK.
// res.json({ message: 'Hello world!' }) — відправляємо відповідь у форматі JSON.

// Маршрутів може бути скільки завгодно

// // GET-запит до кореневого маршруту "/"
// app.get('/', (req, res) => {
//   res.status(200).json({
//     message: 'Hello world!',
//   });
// });

// // GET-запит до маршруту "/health"
// app.get('/health', (req, res) => {
//   res.status(200).json({
//     status: 'Ok!',
//   });
// });

// Таким чином, кожен маршрут в Express — це правило: “як сервер має реагувати на конкретний метод і
// шлях”. За допомогою req ми отримуємо дані від клієнта, а через res відправляємо відповідь.

//!  Динамічні параметри в маршрутах

// У багатьох випадках потрібно отримати конкретний ресурс за його ідентифікатором: користувача за id, товар за id,
// статтю за slug тощо.Для цього в Express використовуються динамічні параметри.

// // Список усіх користувачів
// app.get('/users', (req, res) => {
//   res.status(200).json([{ id: 1, name: 'Alice' }]);
// });

// // Конкретний користувач за id
// app.get('/users/:userId', (req, res) => {
//   const { userId } = req.params;
//   res.status(200).json({ id: userId, name: 'Jacob' });
// });

// GET /users → повертає масив користувачів.
// GET /users/:userId → повертає дані одного користувача.

// У виразі шляху частина з двокрапкою (:userId) означає, що ця частина URL є змінною. Значення параметра потрапляє в об’єкт req.params.

// Приклади:

// Запит GET /users/5 → req.params.userId === "5".
// Запит GET /users/42 → req.params.userId === "42".

// Параметри завжди приходять у вигляді рядків. Якщо потрібне число, його треба конвертувати:

// const userId = Number(req.params.userId);

// Динамічні параметри дозволяють створювати маршрути, які працюють із конкретними ресурсами, а не лише з колекціями.

//!      Middleware у Express

// У Express запити проходять через ланцюжок проміжних обробників — middleware.

// Кожен middleware може змінювати об’єкти req і res, виконувати певні дії(логування, парсинг тіла запиту, перевірку доступу
//   тощо) і передавати обробку далі.

// Middleware додаються через метод app.use:

// app.use(middleware);          // для всіх маршрутів
// app.use('/path', middleware); // тільки для /path/*

// Звичайні middleware мають три аргументи:

// (req, res, next) => { ... }

// req — запит
// res — відповідь
// next — функція, яка передає обробку далі

// Якщо middleware не завершує обробку (res.json, res.send тощо), воно обов’язково має викликати next(). Інакше запит «зависне».

// Приклад: логування часу

// // src/server.js
// import express from 'express';

// const app = express();
// const PORT = 3000;

// // Логування часу
// app.use((req, res, next) => {
//   console.log(`Time: ${new Date().toLocaleString()}`);
//   next();
// });

// // Маршрут
// app.get('/', (req, res) => {
//   res.status(200).json({ message: 'Hello, World!' });
// });

// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// У цьому прикладі запит проходить такі етапи:

// Middleware логування часу.
// Обробник маршруту /.

// Порядок підключення middleware має значення: Express виконує їх у тому порядку, в якому вони оголошені в коді.

// Тепер при GET-запиті сервер буде логувати час і дату у консоль:

// Middleware обробки помилок

// У Express є спеціальний тип middleware, який обробляє помилки. Його особливість у тому, що він завжди має чотири аргументи:

// (err, req, res, next) => { ... }

// err — об’єкт помилки
// req — запит
// res — відповідь
// next — функція для передачі далі (зазвичай не використовується, бо обробку завершує це middleware)

// Express автоматично передає сюди помилки, якщо попереднє middleware або маршрут викликав next(err) чи виникла синхронна помилка.

// Таке middleware завжди підключається останнім після усіх звичайних middleware та маршрутів, інакше воно не перехопить помилки.

// Доповнимо наш приклад з логуванням додавши middleware обробки помилок:

// // src/server.js
// import express from 'express';

// const app = express();
// const PORT = 3000;

// // Логування часу
// app.use((req, res, next) => {
//   console.log(`Time: ${new Date().toLocaleString()}`);
//   next();
// });

// // Маршрут
// app.get('/', (req, res) => {
//   res.status(200).json({ message: 'Hello, World!' });
// });

// // Маршрут для тестування middleware помилки
// app.get('/test-error', (req, res) => {
//   // Штучна помилка для прикладу
//   throw new Error('Something went wrong');
// });

// // Middleware для обробки помилок
// app.use((err, req, res, next) => {
//   console.error('Error:', err.message);
//   res.status(500).json({
//     message: 'Internal Server Error',
//     error: err.message,
//   });
// });

// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// Пізніше ми повернемось до middleware обробки помилок і вдосконалимо її.

// Давайте протестуємо цей код у Postman.У відео нижче ви побачите, як працює маршрут / і як error middleware обробляє штучну
// омилку на маршруті / test - error.
// Дивись відео в папкі Node - Відео до конспекту за такою назвою:
// "5. Модуль 1. Основи Node.js - Middleware у Express"
// Якщо не додати error middleware, сервер просто завершить запит без відповіді, а клієнт отримає «завислий» запит.

//!  Middleware для неіснуючих маршрутів

// Бувають ситуації, коли клієнт звертається до маршруту, якого не існує, тобто до URL, який наш сервіс не підтримує.
// Щоб коректно обробляти такі запити, у Express додають спеціальне middleware для 404 Not Found.

// app.use((req, res) => {
//   res.status(404).json({ message: 'Route not found' });
// });

// Особливість цього middleware у тому, що воно підключається після всіх маршрутів, але перед middleware для обробки
// помилок.Якщо жоден із маршрутів не збігся, керування дійде сюди.

// // src/server.js
// import express from 'express';

// const app = express();
// const PORT = 3000;

// // Логування часу
// app.use((req, res, next) => {
//   console.log(`Time: ${new Date().toLocaleString()}`);
//   next();
// });

// // Кореневий маршрут
// app.get('/', (req, res) => {
//   res.status(200).json({ message: 'Hello, World!' });
// });

// // Маршрут для тестування middleware помилки
// app.get('/test-error', (req, res) => {
//   // Штучна помилка для прикладу
//   throw new Error('Something went wrong');
// });

// // Middleware 404 (після всіх маршрутів)
// app.use((req, res) => {
//   res.status(404).json({ message: 'Route not found' });
// });

// // Middleware для обробки помилок (останнє)
// app.use((err, req, res, next) => {
//   console.error('Error:', err.message);
//   res.status(500).json({
//     message: 'Internal Server Error',
//     error: err.message,
//   });
// });

// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// У цьому прикладі обробка запиту проходить так:

// Middleware логування часу.
// Якщо шлях /, виконується обробник маршруту.
// Якщо шлях не знайдено — спрацьовує 404 middleware.
// Якщо виникла помилка — спрацьовує error middleware.

// Таким чином клієнт завжди отримає зрозумілу відповідь:
// - або дані,
// - або повідомлення про відсутність маршруту,
// - або опис помилки.

// Тепер при GET - запиті на будь - який неіснуючий маршрут, наприклад http://localhost:3000/random, сервер поверне відповідь
// із повідомленням про відсутність маршруту.

// !  Middleware із бібліотек

// Багато типових завдань у вебзастосунках вже вирішені готовими бібліотеками.У цьому розділі розглянемо три найпоширеніші приклади:
// робота з JSON, підтримка CORS і логування запитів.

// Обробка JSON

// Більшість сучасних вебзастосунків обмінюються даними у форматі JSON.У Express для цього є вбудоване middleware — express.json().
// Воно автоматично парсить(розпаковує) тіло HTTP - запиту, якщо воно надійшло у форматі JSON, і додає його у req.body.

// // src/server.js
// import express from 'express';

// const app = express();
// const PORT = 3000;

// // Middleware для парсингу JSON
// app.use(express.json());

// app.post('/users', (req, res) => {
//   console.log(req.body); // тепер тіло доступне як JS-об’єкт
//   res.status(201).json({ message: 'User created' });
// });

// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// Тепер, якщо відправити POST - запит із JSON - тілом, сервер автоматично розпарсить його і збереже у req.body як JavaScript - об’єкт.
// У нашому прикладі ми ще не використовуємо POST чи PATCH маршрути, але express.json() настільки базове та поширене middleware,
//   що його варто підключати одразу.

// CORS

// CORS (Cross-Origin Resource Sharing) — механізм безпеки, який дозволяє браузеру робити запити з одного домену до іншого.

// Наприклад, ваш фронтенд працює на http://localhost:3000, а бекенд — на http://localhost:5000. Без CORS браузер заблокує такі запити.

// Щоб дозволити обмін даними, сервер має вказати у відповідях спеціальний заголовок:

// Access-Control-Allow-Origin: *

// Це означає, що доступ дозволений з будь-якого джерела. В Express для цього використовують пакет cors:

// npm install cors

// Підключення у коді:

// // src/server.js
// import express from 'express';
// import cors from 'cors';

// const app = express();

// app.use(express.json());
// app.use(cors()); // Дозволяє запити з будь-яких джерел

// // Решта коду

// У більш складних випадках можна задавати конкретні домени чи методи, але для базового застосунку цього достатньо.

// Логування запитів

// Логування допомагає відслідковувати, як працює застосунок: які запити надходять, які відповіді повертаються і скільки часу займає обробка.

// Ми використаємо сучасний логер pino-http. Він дуже швидкий і простий у налаштуванні.

// Встановлення:

// npm install pino-http pino-pretty

// Підключення у коді:

// // src/server.js
// import express from 'express';
// import cors from 'cors';
// import pino from 'pino-http';

// const app = express();
// const PORT = 3000;

// // Middleware
// app.use(express.json());
// app.use(cors());
// app.use(
//   pino({
//     level: 'info',
//     transport: {
//       target: 'pino-pretty',
//       options: {
//         colorize: true,
//         translateTime: 'HH:MM:ss',
//         ignore: 'pid,hostname',
//         messageFormat: '{req.method} {req.url} {res.statusCode} - {responseTime}ms',
//         hideObject: true,
//       },
//     },
//   }),
// );

// // Решта коду

// Налаштування Pino досить гнучкі — можна створити будь - який формат логів.У нашому випадку ми використовуємо готову
// конфігурацію, яка робить повідомлення у консолі зручними та читабельними: кольоровий текст, час запиту, HTTP - метод,
//   шлях і статус відповіді.

//!   Змінні оточення

// Будь - який застосунок має працювати в різних середовищах: на локальному комп’ютері, у тестовому середовищі чи на продакшені.
// Для кожного з них можуть відрізнятися налаштування: адреси баз даних, API - ключі, секрети або інші параметри.Саме для цього існують змінні оточення.

// Змінні оточення(environment variables) — це змінні, що зберігають конфігураційні параметри програми.Вони дозволяють винести
// чутливу або специфічну для середовища інформацію за межі коду.

// Зазвичай такі змінні оголошуються у файлі .env, який створюється в корені проєкту. Наприклад, порт, на якому запускається сервер:

// # .env

// PORT=3000

//   .env обов’язково додається в.gitignore і ніколи не комітиться в репозиторій.Якщо випадково закомітили — потрібно негайно змінити
// всі ключі й паролі.Навіть видалення файлу у наступному коміті не прибере його з історії.

// Доброю практикою є створення файлу.env.example, де перелічуються всі змінні без реальних значень.Це допомагає іншим розробникам
// налаштувати своє середовище:

// # .env.example

// PORT=9999

// Використання змінних у коді

// Щоб зчитувати .env, встановлюємо пакет dotenv:

// npm install dotenv

// Імпортуємо його у коді:

// // src/server.js

// // Такий імпорт одразу ініціалізує бібліотеку
// import 'dotenv/config';

// У Node.js змінні доступні через глобальний об’єкт process.env:

// // src/server.js

// import express from 'express';
// import cors from 'cors';
// import pino from 'pino-http';
// import 'dotenv/config';

// const app = express();

// // Використовуємо значення з .env або дефолтний порт 3000
// const PORT = process.env.PORT ?? 3000;

// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// Значення у process.env завжди є рядками.Якщо потрібен інший тип(наприклад число чи булеве значення), його слід явно конвертувати.
// Використання дефолтного значення(?? 3000) захистить від ситуацій, коли змінна у.env ще не вказана.

// Middleware обробки помилок

// Наша мідлвара для обробки помилок у поточному вигляді завжди відправляє користувачу деталі помилки(err.message).Це зручно під
// час розробки, але в продакшені так робити небезпечно — користувач може побачити внутрішню інформацію про застосунок.

// Щоб вирішити цю проблему, ми додамо змінну оточення NODE_ENV, яка буде вказувати, у якому середовищі працює застосунок:

// development — режим розробки (показуємо деталі помилки і стек).
// production — продакшн (повертаємо лише загальне повідомлення).

// Оновлюємо файл .env у корені проєкту:

// #.env
// PORT=3000
// NODE_ENV=development

// Тепер під час локальної розробки process.env.NODE_ENV матиме значення development.

// Оновлений код middleware:

// // src/server.js

// // Решта коду файла

// // Middleware для обробки помилок
// app.use((err, req, res, next) => {
//   console.error(err);

//   const isProd = process.env.NODE_ENV === "production";

//   res.status(500).json({
//     message: isProd
//       ? "Something went wrong. Please try again later."
//       : err.message,
//   });
// });

// // Решта коду файла

// При деплої продакшн - версії на Render.com змінна NODE_ENV автоматично матиме значення "production", навіть якщо ви її не задавали.
// Це гарантує, що у продакшені деталі помилок не потраплять у відповідь.

//!   Деплой бекенда

// Ви вже знайомі з поняттям деплой, адже раніше розгортали фронтенд - застосунки(наприклад, на Vercel чи Netlify).
// Тепер настав час зрозуміти, як відбувається деплой бекенда.

//   Фронтенд — це статичні файли(HTML, CSS, JS), які сервер просто віддає користувачеві.Коли ви деплоїте фронтенд, хостинг
// лише зберігає ці файли та робить їх доступними у браузері.

//   Бекенд — це вже живий застосунок, який постійно працює у пам’яті сервера, слухає порт і обробляє HTTP - запити.Тобто,
//     коли ми деплоїмо бекенд, ми фактично запускаємо програму на віддаленому комп’ютері, доступну 24 / 7.

// Render.com

// Для розгортання бекенда ми будемо використовувати Render.com — платформу, яка автоматизує запуск Node.js-додатків.

// Вона бере ваш код із GitHub, встановлює залежності, запускає сервер і робить його доступним у мережі.

// Render зручно підходить для навчальних і продакшн-проєктів, бо:

// підтримує безкоштовний тариф,
// має просту інтеграцію з GitHub,
// дозволяє налаштовувати змінні оточення (наприклад, PORT чи ключі до БД),
// автоматично видає публічний HTTPS-URL.

// При деплої на Render.com вам не потрібно вручну створювати змінну NODE_ENV. Сервіс автоматично встановить її значення в "production", навіть якщо ви цього не зробите самі. Це означає, що ваш застосунок одразу працюватиме у безпечному продакшн-режимі, де деталі помилок не відправляються користувачу.

// Детальні кроки ви побачите у відео, де ми розбираємо процес деплою бекенда на render.com.
// Дивись відео в папкі Node - Відео до конспекту за такою назвою:
// "6. Модуль 1. Основи Node.js - Деплой бекенда на Render.com"

// todo TASK

// Критерії приймання

// Створений репозиторій з назвою nodejs-hw
// Завдання виконано на гілці 01-express
// Надано посилання на вихідний код у GitHub
// Надано посилання на задеплоєний проєкт на render.com
// Код виконується без помилок
// Використовується змінна PORT через dotenv
// Підключено cors
// Підключено express.json()
// Налаштований логер pino-http
// Додано middleware для 404
// Додано middleware для помилок 500
// Файлова структура відповідає вимогам
// Реалізований маршрут GET /notes
// Реалізований маршрут GET /notes/:noteId
// Реалізований маршрут GET /test-error

// Створення проєкту

// Ініціалізуйте проєкт командою npm init -y

// Додайте в залежності проєкта eslint та підкорегуйте його конфігураційний файл згідно наданого прикладу в матеріалах.

// Додайте у корінь проєкта файли .gitignore та .prettierrc з відповідним вмістом.

// Встановіть nodemon як залежність для розробки.Додайте скрипт "start", "dev" у файл package.json, щоб запускати сервер за допомогою
// nodemon.Для цього відредагуйте розділ scripts.

// Файлова структура

// Створіть в корні проєкта папку src.

// В папці src створіть файл із назвою server.js.В ньому буде знаходитись логіка роботи вашого express - серверу.У вас має вийти
// наступна структура файлів і папок:

// Така структура потрібна, щоб відділити логіку додатка (src) від конфігурації та допоміжних файлів, що лежать у корені проєкту.

// Змінні оточення

// Створіть файл .env для зберігання змінних, додайте в нього змінну PORT.

// Запуск express - сервера має відбуватись на порті, вказаному через змінну оточення PORT або 3000, якщо такої змінної не було отримано.
// Використайте пакет dotenv для її підвантаження.

// Реалізація маршрутів

// Поки у нас немає повноцінної бази даних, наш express - сервер тимчасово буде повертати не повноцінні дані про нотатки, а
// об’єкт з відповідним повідомленням.

// Ваш сервер має надавати такі маршрути для роботи з нотатками:

// маршрут, який буде повертати всі нотатки:

// GET /notes

// Відповідь сервера має бути зі статусом 200 та містити наступний об'єкт:
// {
// 	"message": "Retrieved all notes"
// }

// маршрут, який буде повертати одну нотатку за її ідентифікатором:
// GET /notes/:noteId

// Відповідь сервера має бути зі статусом 200 та містити наступний об'єкт:
// {
// 	"message": "Retrieved note with ID: id_param"
// }

// де id_param — це значення параметра noteId із запиту.

// Middleware

// Додайте до вашого серверу стандартні Middleware:

// cors — дозволяє робити запити з інших доменів;
// express.json() — дозволяє обробляти дані у форматі JSON, які надходять у body запиту.

// Додайте до вашого серверу Middleware для логування:

// У файлі src / server.js налаштуйте логування HTTP - запитів за допомогою пакета pino - http.Це допоможе бачити, які запити
// надходять на сервер.

// Обробка неіснуючих маршрутів

// Додайте до src/server.js middleware для обробки всіх запитів, що не відповідають жодному наявному маршруту.

// Відповідь сервера у такому випадку має бути зі статусом 404 та містити наступний об'єкт:

// {
//   "message": "Route not found"
// }

// Наприклад, якщо надійдуть такі запити:

// GET /profile
// GET /payments

// — цей middleware повинен їх перехопити та відповісти 404, бо ці маршрути не реалізовані у вашому сервері.

// Обробка помилок

// У файлі src/server.js реалізуйте middleware що перехоплює помилки.

// Відповідь сервера у такому випадку має бути зі статусом 500 та містити наступний об'єкт з повідомленням про помилку:

// {
//   "message": <повідомлення про помилку>
// }

// Створіть спеціальний тестовий маршрут для імітації виникнення помилки:

// GET /test-error

// з таким обробником:

// app.get('/test-error', () => {
//   throw new Error('Simulated server error');
// });

// Деплой

// Задеплойте ваш додаток з гілки 01-express на render.com.

//     Дуже важливо перед здачею дз на перевірку ментору перевіряти роботу вашого задеплоєного додатка на render.com.
//     Якщо, наприклад, при деплої ви забули додати змінні оточення (env), то задеплоєний бекенд не буде працювати.
//     Також перевірте, що всі створені вами маршрути бекенду працюють як очікується згідно з завданням.

// Results
// Version 2/2
// Task 1

// Завдання вирішено правильно (файл src/server.js)

// Добре реалізовані аспекти:

// Сервер реалізовано з використанням Express та ES-модулів.
// Змінні середовища завантажуються через 'dotenv/config'.
// Сервер слухає порт, вказаний у PORT, або за замовчуванням використовує 3000.
// CORS увімкнено для всіх маршрутів.
// Додано middleware express.json().
// Логування HTTP-запитів інтегровано з використанням pino-http.
// Усі необхідні маршрути (/notes, /notes/:noteId, /test-error) реалізовані з правильною структурою відповіді.
// Невідомі маршрути обробляються зі статусом 404 та відповідним JSON-повідомленням.
// Присутнє middleware для обробки помилок, яке повертає JSON-відповідь.
// Сервер логгує повідомлення з вказанням порту, на якому працює.
// Додаткові пропозиції:

// Включення helmet є хорошою практикою безпеки, хоча для цього завдання це не обов’язково.
// Фінальне рішення:

// Завдання прийнято

//!  Заняття 3. Бази даних

// Що таке бази даних?

// Ви вже працювали з масивами та об’єктами у JavaScript. Це теж спосіб зберігати дані, але підходить лише для невеликих програм.

// А що робити, якщо потрібно зберігати тисячі чи навіть мільйони записів ? Наприклад, усіх користувачів Instagram або всі замовлення в
// інтернет - магазині ?

// Тут на допомогу приходять бази даних(БД).Вони є основою будь - якої сучасної системи: від маленьких сайтів до великих сервісів на
// кшталт YouTube чи Facebook.

// База даних (Database) — це організоване місце для зберігання даних, яке дозволяє їх швидко додавати, шукати, змінювати та видаляти.

// Основні характеристики баз даних

// Дані.База даних містить інформацію, яка може бути структурованою у вигляді таблиць, документів, ключів - значень, графів чи інших
// форматів — залежно від типу бази.
//   Маніпуляція.Бази даних дозволяють виконувати різні операції над даними: додавати нові записи, змінювати їх, видаляти чи знаходити
// за певними умовами.Для цього можуть використовуватись SQL - запити або інші мови.
//   Структура.Дані можуть бути організовані по - різному: у вигляді таблиць(реляційні БД), у вигляді документів(JSON - подібних об’єктів),
//     у графах, де важливі зв’язки між сутностями тощо.
// Збереження. Бази даних забезпечують довготривале зберігання інформації на дисках або інших носіях, навіть після перезавантаження системи.
//   Цілісність.СУБД(системи управління базами даних) мають механізми, які гарантують, що дані залишаються узгодженими й коректними,
//     навіть при великих обсягах чи паралельних запитах.
// Доступ. Бази надають ефективний спосіб доступу до даних для користувачів та програм, дозволяючи швидко знаходити потрібну інформацію.
// Безпека. Захист від несанкціонованого доступу та контроль прав користувачів є ключовими складовими будь-якої сучасної бази.

// Реляційні та нереляційні бази даних

// Усі бази даних можна поділити на два великі типи: реляційні та нереляційні.

// Реляційні бази даних

// Зберігають дані у вигляді таблиць (рядки та колонки).
// Між таблицями можна будувати зв’язки. Наприклад: таблиця users і таблиця orders, де кожне замовлення має посилання на користувача.
// Використовують мову SQL для роботи з даними.
// Добре підходять для структурованих даних і складних зв’язків.
// Приклади: MySQL, PostgreSQL, Oracle.

// Можна уявити реляційну БД як Excel-таблиці, але з дуже великими можливостями.

// Нереляційні бази даних

// Використовують інші структури даних:
// Документи (JSON-об’єкти).
// Ключ-значення (як словник у JS).
// Графи (зв’язки між елементами).
// Немає суворої схеми: кожен запис може мати свій набір полів.
// Легко масштабуються та зручні, коли структура даних часто змінюється.
// Приклади: MongoDB, Redis, Cassandra.

// Нереляційну БД можна уявити як велику колекцію об’єктів у JavaScript.

// MongoDB

// У нашому курсі ми будемо працювати з MongoDB.

// MongoDB — це нереляційна база даних, яка зберігає дані у вигляді документів, схожих на JavaScript-об’єкти:

// {
//   "id": 1,
//   "name": "Alice",
//   "email": "alice@mail.com"
// }

// Це робить MongoDB дуже зручною для фронтенд-розробників: дані виглядають так само як і у вашому JS-коді.

// Основні переваги MongoDB

// Гнучкість схеми. Можна додавати нові поля без змін у всій базі.
// Швидкість. Добре працює з великими обсягами даних.
// Масштабованість. Підтримує розподіл даних між кількома серверами.
// Надійність. Вміє створювати копії даних (реплікацію), щоб база працювала навіть при збоях.
// Зручність. Формат зберігання дуже схожий на JSON, тож працювати з ним легко.

// MongoDB використовують такі компанії, як eBay, Uber, Adobe, Lyft, LinkedIn.

//!  MongoDB Atlas

// Уявіть собі величезний склад, де зберігаються всі ваші дані.Так працює база даних MongoDB: вона зберігає інформацію у вигляді
// окументів, які виглядають як JavaScript - об’єкти.

// {
//   "id": 1,
//   "name": "Alice",
//   "email": "alice@mail.com"
// }

// MongoDB можна встановити локально на комп’ютер, але набагато зручніше користуватися її хмарною версією.

// MongoDB Atlas — це сервіс, який дозволяє створити та використовувати базу даних у хмарі.Вам не потрібно налаштовувати
// сервери вручну — достатньо зареєструватися, і ви отримаєте готовий кластер.

// Кластер — це група серверів, які працюють разом, щоб:

// база даних завжди була доступною,
// дані не зникли при збої,
// запити виконувались швидко навіть під великим навантаженням.

// Тобто, якщо звичайна база — це просто склад, то кластер у

// MongoDB Atlas — це склад із додатковими "охоронцями", резервними копіями та можливістю швидко збільшувати площу, якщо з’являється більше товару (даних).

// Створення акаунту

// Щоб почати роботу:

// Переходимо на MongoDB Atlas.
// Реєструємо акаунт.
// Створюємо кластер (це буде наша база в хмарі).

// Відео-демо процесу реєстрації:

// Дивись відео в папкі Node- відео до конспекту:

// "7. Модуль 2. Бази даних-MongoDB Atlas"

// Збереження даних підключення

// Після створення бази ви отримаєте спеціальний connection string — рядок підключення. Наприклад:

// mongodb+srv://borismeshkovaws:12345678@cluster0.xpxkilq.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0

// У код його додавати не можна — це небезпечно.Натомість ми збережемо ці дані у файлі.env, щоб зручно працювати з різними
// середовищами(локально, на тесті, у продакшені).

// # .env

// PORT=3000
// MONGO_URL=mongodb+srv://borismeshkovaws:12345678@cluster0.xpxkilq.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0

// І не забудьте оновити файл .env.example, щоб інші розробники бачили, які змінні треба налаштувати:

// # .env.example
// PORT=
// MONGO_URL=

// Підключення MongoDB

// Щоб працювати з базою даних, нам потрібно підключитися до неї зі свого бекенду.Робити це "вручну" через драйвер MongoDB
// незручно, тому ми використаємо бібліотеку Mongoose.

// Mongoose спрощує роботу з базою:

// дозволяє легко підключитися,
// працювати з колекціями як з об’єктами,
// будувати схеми та моделі для даних.

// Встановлюємо пакет у наш проєкт:

// npm install mongoose

// Файл для підключення

// Щоб код був структурованим, створимо у папці src нову папку db, а в ній файл connectMongoDB.js.Там ми напишемо функцію
// для підключення до бази даних.

// // src/db/connectMongoDB.js
// import mongoose from 'mongoose';

// export const connectMongoDB = async () => {
//   try {
//     const mongoUrl = process.env.MONGO_URL;
//     await mongoose.connect(mongoUrl);
//     console.log('✅ MongoDB connection established successfully');
//   } catch (error) {
//     console.error('❌ Failed to connect to MongoDB:', error.message);
//     process.exit(1); // аварійне завершення програми
//   }
// };

// Тут ми:

// читаємо рядок підключення (MONGO_URL) зі змінних оточення,
// викликаємо mongoose.connect(...) для встановлення з’єднання,
// у разі успіху виводимо повідомлення,
// у разі помилки завершуємо роботу процесу (process.exit(1)), щоб сервер не залишався "напівживим".

// Виклик у сервері

// У файлі src/server.js імпортуємо та викликаємо функцію перед запуском сервера:

// // src/server.js

// import express from 'express';
// import 'dotenv/config';
// import cors from 'cors';
// import { connectMongoDB } from './db/connectMongoDB.js';

// const app = express();
// const PORT = process.env.PORT ?? 3030;

// /* Middleware та маршрути */

// // підключення до MongoDB
// await connectMongoDB();

// // запуск сервера
// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// У сучасному Node.js ми можемо використовувати top - level await.Це означає, що await можна викликати прямо у файлі модуля,
//   а не тільки всередині async функції.Це зручно, бо дозволяє писати асинхронний код на верхньому рівні програми.

//!  MongoDB Compass
// Імпорт даних у MongoDB

// Працювати з базою даних можна різними способами: через командний рядок, напряму з коду або за допомогою зручних інструментів з графічним інтерфейсом. Для початку ми використаємо MongoDB Compass — офіційний інструмент зручної роботи з MongoDB.

// MongoDB Compass — це програма, яка дозволяє переглядати базу даних у зрозумілому віконному інтерфейсі. Вона значно полегшує роботу:

// можна переглядати колекції та документи,
// редагувати записи,
// виконувати пошук і фільтрацію,
// імпортувати та експортувати дані.

// Це хороший старт, бо дає можливість швидко ознайомитися з тим, як виглядають дані у базі.

// При завантаженні обирайте саме MongoDB Compass Download (GUI) — це потрібна нам версія.
// Встановлення MongoDB Compass

// Ось відеоінструкція з встановлення та перших кроків роботи:

// " 8. Модуль 2. Бази даних-MongoDB  Compass"

// Імпорт тестових даних

// Щоб мати з чим працювати далі на практиці, ми одразу додамо у базу даних тестову колекцію студентів. Для цього:

// 1. Завантажте файл із даними:

// students.json

// 2. Використайте функцію імпорту в Compass, щоб додати ці дані у нову базу даних Students.

// Відео з покроковою інструкцією:

// "9. Модуль 2. Бази даних-MongoDB  Compass"

// Після імпорту у вас з’явиться готова колекція студентів, яку ми будемо використовувати для навчання: шукати, змінювати,
// видаляти та додавати нові записи.

// Підключення до конкретної бази даних

// У MongoDB Atlas ми можемо працювати з багатьма базами даних в одному кластері.Але для нашого проєкту важливо, щоб сервер
// одразу підключався саме до тієї бази, з якою ми працюємо.

// Ми вже створили базу даних students, тому потрібно вказати її назву у змінній оточення.Для цього після mongodb.net / у
// connection string додаємо назву бази(students) перед параметрами ? retry....

// Файл .env тепер виглядає так:

// # .env

// PORT=3000
// MONGODB_URL=mongodb+srv://borismeshkovaws:12345678@cluster0.xpxkilq.mongodb.net/students?retryWrites=true&w=majority&appName=Cluster0

// Тепер при підключенні через Mongoose ми одразу працюємо з базою students.Це означає, що всі наші моделі та колекції будуть
// створюватися й зберігатися саме в цій базі.

// Mongoose читає повний рядок підключення з process.env.MONGODB_URL, тому код підключення в connectMongoDB лишається без змін.

//!  Модель даних

// У цьому модулі ми будемо створювати бекенд для адмін - панелі навчального закладу, де ведеться облік студентів.Тому нашою першою
// моделлю буде студент.

//   MongoDB — це документоорієнтована NoSQL база даних, яка зберігає дані у вигляді документів у форматі BSON(Binary JSON).Модель
// даних у MongoDB базується на колекціях і документах.

// Основні поняття MongoDB

// Колекція (Collection): група документів. Можна уявити як масив об’єктів.
// Документ (Document): основна одиниця даних. Це JSON-подібний об’єкт у форматі BSON.
// Поле (Field): пара «ключ-значення» всередині документа.
// Ідентифікатор (_id): унікальне поле, яке автоматично створюється для кожного документа.

// Основні поняття Mongoose

// Щоб працювати з MongoDB, ми будемо використовувати бібліотеку Mongoose, яка спрощує опис структури документів.У ній є кілька
// ключових понять:

// Схема (Schema): описує структуру документа (які поля і з якими типами будуть).
// Модель (Model): клас, створений на основі схеми. Використовується для роботи з колекцією.
// Документ (Document): конкретний екземпляр моделі, який відповідає запису в базі даних.

// Схема студента

// Створимо схему для документа студента. Для цього використаємо клас Schema з бібліотеки mongoose.

// // src/models/student.js

// import { Schema } from 'mongoose';

// const studentSchema = new Schema(
//   {
//     name: {
//       type: String,
//       required: true,
//       trim: true, // прибирає пробіли на початку та в кінці
//     },
//     age: {
//       type: Number,
//       required: true,
//     },
//     gender: {
//       type: String,
//       required: true,
//       enum: ['male', 'female', 'other'],
//     },
//     avgMark: {
//       type: Number,
//       required: true,
//     },
//     onDuty: {
//       type: Boolean,
//       default: false,
//     },
//   },
//   {
//     timestamps: true,
//     versionKey: false,
//   },
// );

// Пояснення

// type — тип даних (String, Number, Boolean).
// required — чи поле обов’язкове.
//   trim: true — автоматично видаляє зайві пробіли на початку та в кінці рядка.Корисно для текстових полів, таких як name, щоб уникнути
// збереження значень на кшталт " John ".
// enum — перелік допустимих значень (наприклад, для gender).
// default — значення за замовчуванням, якщо поле не передано.
// timestamps — автоматично додає createdAt і updatedAt.
// versionKey: false — вимикає службове поле __v.

// Модель студента

// Створимо модель Student на основі нашої схеми:

// // src/models/student.js

// import { model } from 'mongoose';

// /* Решта коду файла */

// export const Student = model('Student', studentSchema);

// Mongoose автоматично створить колекцію students у базі даних(назва береться у множині).Тепер ми можемо використовувати
// модель Student для взаємодії з колекцією: створювати нових студентів, отримувати список, оновлювати чи видаляти записи.

//!  Взаємодія з базою даних

// Тепер, коли ми вже маємо базу students та модель Student, додамо маршрути для взаємодії з нею.Почнемо з отримання всіх студентів
// та отримання одного студента за його id.

// Маршрут: отримати всіх студентів

// У цьому маршруті ми будемо звертатися до колекції students через вбудований метод Mongoose Student.find(), який повертає масив
// документів(може бути порожнім), що відповідають моделі Student.

// // src/server.js

// import { Student } from './models/student.js';
// // Код імпортів та підключення middleware бібліотек

// app.get('/students', async (req, res) => {
//   const students = await Student.find();
//   res.status(200).json(students);
// });

// // Код 404 та error middleware, підключення до бази даних та старт сервера
// Маршрут: отримати одного студента за id

// Для цього маршруту ми використаємо вбудований метод Mongoose Student.findById().Якщо документ із заданим ідентифікатором не
// буде знайдено, метод поверне null.У такому випадку ми повернемо статус 404.

// // src/server.js

// // Решта коду

// app.get('/students/:studentId', async (req, res) => {
//   const { studentId } = req.params;
//   const student = await Student.findById(studentId);

//   if (!student) {
//     return res.status(404).json({ message: 'Student not found' });
//   }

//   res.status(200).json(student);
// });

// // Решта коду

// Властивість params на об’єкті запиту req містить динамічні параметри маршруту.Кожне ім’я параметра відповідає властивості цього об’єкта,
//  а значення, передане в URL, стає значенням цієї властивості.

// Повний код із підключенням middleware

// // src/server.js

// import express from 'express';
// import 'dotenv/config';
// import cors from 'cors';
// import { connectMongoDB } from './db/connectMongoDB.js';
// import { Student } from './models/student.js';

// const app = express();
// const PORT = process.env.PORT ?? 3000;

// app.use(express.json());
// app.use(cors());

// // GET /students — список усіх студентів
// app.get('/students', async (req, res) => {
//   const students = await Student.find();
//   res.status(200).json(students);
// });

// // GET /students/:studentId — один студент за id
// app.get('/students/:studentId', async (req, res) => {
//   const { studentId } = req.params;
//   const student = await Student.findById(studentId);
//   if (!student) {
//     return res.status(404).json({ message: 'Student not found' });
//   }
//   res.status(200).json(student);
// });

// // Middleware 404
// app.use((req, res) => {
//   res.status(404).json({ message: 'Route not found' });
// });

// // Middleware для обробки помилок
// app.use((err, req, res, next) => {
//   console.error(err);

//   const isProd = process.env.NODE_ENV === "production";

//   res.status(500).json({
//     message: isProd
//       ? "Something went wrong. Please try again later."
//       : err.message,
//   });
// });

// await connectMongoDB();

// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// Тепер ми маємо:

// GET <http://localhost:3000/students> → повертає всіх студентів.
// GET <http://localhost:3000/students/:studentId> → повертає одного студента або 404, якщо такого немає.

//! Організація middleware

// Коли наш код зростає, важливо зберігати його структурованим і зрозумілим. Якщо всі middleware та маршрути будуть в одному
// файлі server.js, швидко виникне плутанина. Тому ми виносимо middleware в окремі файли. Це дає кілька переваг:

// легше читати код, бо кожен файл відповідає за одну конкретну задачу;
// простіше підтримувати — якщо треба змінити тільки логування або обробку помилок, ми працюємо з окремим файлом;
// масштабованість — у майбутньому легко додати нові middleware без засмічення server.js.

// Структура проєкту

// Створюємо в папці src нову папку middleware і кладемо туди наші кастомні middleware.

// src/
//   middleware/
//     errorHandler.js
//     notFoundHandler.js
//     logger.js
//   server.js

// Error middleware

// Перенесемо middleware для обробки помилок у файл errorHandler.js.
// // src/middleware/errorHandler.js

// app.use((err, req, res, next) => {
//   console.error(err);

//   const isProd = process.env.NODE_ENV === "production";

//   res.status(500).json({
//     message: isProd
//       ? "Something went wrong. Please try again later."
//       : err.message,
//   });
// });

// Це middleware має 4 аргументи (err, req, res, next) — саме за цим Express розуміє, що воно призначене для помилок.
// Використовується завжди останнім, щоб перехопити всі помилки з попередніх обробників.
// Ми виводимо помилку в консоль і повертаємо клієнту відповідь зі статусом 500 Internal Server Error.

// 404 middleware

// Тепер винесемо обробку випадку, коли клієнт звертається до неіснуючого маршруту. Для цього створимо notFoundHandler.js.

// // src/middleware/notFoundHandler.js

// export const notFoundHandler = (req, res) => {
//   res.status(404).json({ message: 'Route not found' });
// };

// Це middleware підключається після всіх маршрутів.
// Якщо жоден маршрут не збігся, керування потрапить сюди.
// Ми відправляємо клієнту відповідь зі статусом 404 Not Found.

// Логер Pino

// Щоб бачити всі запити, підключимо pino-http у logger.js.

// // src/middleware/logger.js

// import pino from 'pino-http';

// export const logger = pino({
//   level: 'info',
//   transport: {
//     target: 'pino-pretty',
//     options: {
//       colorize: true,
//       translateTime: 'HH:MM:ss',
//       ignore: 'pid,hostname',
//       messageFormat: '{req.method} {req.url} {res.statusCode} - {responseTime}ms',
//       hideObject: true,
//     },
//   },
// });

// Логер дозволяє відстежувати всі запити до сервера: метод (GET, POST), шлях, статус відповіді, час виконання.
// Ми використовуємо pino-pretty, щоб логи в консолі були кольоровими та зручними для читання.
// Логер треба підключати одним із перших middleware, щоб він бачив усі запити та помилки.

// Підключення в сервері

// Тепер у server.js імпортуємо всі ці middleware та використовуємо їх у правильному порядку.

// // src/server.js
// import express from 'express';
// import 'dotenv/config';
// import cors from 'cors';

// import { connectMongoDB } from './db/connectMongoDB.js';
// import { logger } from './middleware/logger.js';
// import { notFoundHandler } from './middleware/notFoundHandler.js';
// import { errorHandler } from './middleware/errorHandler.js';

// const app = express();
// const PORT = process.env.PORT ?? 3000;

// // Глобальні middleware
// app.use(logger);         // 1. Логер першим — бачить усі запити
// app.use(express.json()); // 2. Парсинг JSON-тіла
// app.use(cors());         // 3. Дозвіл для запитів з інших доменів

// // ...тут ваші маршрути

// // 404 — якщо маршрут не знайдено
// app.use(notFoundHandler);

// // Error — якщо під час запиту виникла помилка
// app.use(errorHandler);

// await connectMongoDB();

// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// Чому порядок важливий?

// Logger першим → логуються всі вхідні запити.
// JSON і CORS далі → кожен запит обробляється перед передачею в маршрути.
// Маршрути → відповідають на конкретні запити.
// 404 handler → якщо маршрут не знайдено.
// Error handler → якщо трапилась помилка на будь-якому етапі.

//!  Організація роутингу

// До цього ми писали обробники запитів безпосередньо у файлі server.js. Якщо маршрутів стає більше, зручніше винести їх у
// окремі файли й групувати за доменами (наприклад, students, auth, courses). Для цього є Express Router — об'єкт, який дозволяє
// групувати маршрути та їх обробники у логічні блоки.

// Створюємо роутер для студентів

// Створіть файл src/routes/studentsRoutes.js. Тут оголошуємо роутер і одразу експортуємо його. Це «порожня рамка», у яку додамо
// маршрути.

// // src/routes/studentsRoutes.js

// import { Router } from 'express';

// const router = Router();

// export default router;

// Переносимо обробники у роутер

// Далі переносимо контролери, які обробляють маршрути /students та /students/:studentId із файла server.js у файл роутингу
// studentsRoutes.js. Для їх оголошення замість app використовуємо створений router.

// // src/routes/studentsRoutes.js

// import { Router } from 'express';
// import { Student } from '../models/student.js';

// const router = Router();

// router.get('/students', async (req, res) => {
//   const students = await Student.find();
//   res.status(200).json(students);
// });

// router.get('/students/:studentId', async (req, res) => {
//   const { studentId } = req.params;
//   const student = await Student.findById(studentId);
//   if (!student) {
//     return res.status(404).json({ message: 'Student not found' });
//   }
//   res.status(200).json(student);
// });

// export default router;

// Підключаємо роутер

// Тепер імпортуємо створений роутер у файл server.js та додаємо його як middleware до app, за допомогою методу app.use().

// // src/server.js

// import express from 'express';
// import 'dotenv/config';
// import cors from 'cors';

// import { connectMongoDB } from './db/connectMongoDB.js';
// import { logger } from './middleware/logger.js';
// import { notFoundHandler } from './middleware/notFoundHandler.js';
// import { errorHandler } from './middleware/errorHandler.js';

// import studentsRoutes from './routes/studentsRoutes.js';

// const app = express();
// const PORT = process.env.PORT ?? 3000;

// // глобальні middleware
// app.use(logger);
// app.use(express.json());
// app.use(cors());

// // підключаємо групу маршрутів студента
// app.use(studentsRoutes);

// // 404 і обробник помилок — наприкінці ланцюжка
// app.use(notFoundHandler);
// app.use(errorHandler);

// await connectMongoDB();

// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

// Підсумок

// Така організація коду створює зрозумілу структуру проєкту:

// server.js відповідає за складання застосунку та запуск сервера;
// роутери містять логіку для роботи з конкретними сутностями (у нашому випадку — студентами);
// моделі визначають доступ до бази даних.
// Цей підхід робить код більш чистим, масштабованим і зручним у підтримці.

//! Організація контролерів

// Ми вже винесли маршрути в окремий файл, але в ньому все ще залишилася логіка обробки запитів. Якщо маршрути будуть складнішими,
// код швидко стане важким для читання. Щоб уникнути цього, створимо окремий шар контролерів.

// Контролери — це функції, які відповідають за обробку запитів і формування відповіді. Роутер лише «знає», який контролер викликати
// для конкретного маршруту, а саму логіку ми зберігаємо в іншому місці. Це робить код більш організованим і зрозумілим.

// Створюємо контролери

// Створіть папку src/controllers, а в ній файл studentsController.js. У цей файл винесемо контролери, які зараз знаходяться у
// файлі studentsRoutes.js.

// // src/controllers/studentsController.js

// import { Student } from '../models/student.js';

// // Отримати список усіх студентів
// export const getStudents = async (req, res) => {
//   const students = await Student.find();
//   res.status(200).json(students);
// };

// // Отримати одного студента за id
// export const getStudentById = async (req, res) => {
//   const { studentId } = req.params;
//   const student = await Student.findById(studentId);

//   if (!student) {
//     return res.status(404).json({ message: 'Student not found' });
//   }

//   res.status(200).json(student);
// };

// Використовуємо контролери у роутері

// Тепер оновимо файл src/routes/studentsRoutes.js, щоб замість логіки напряму викликати контролери.

// // src/routes/studentsRoutes.js

// import { Router } from 'express';
// import {
// 	getStudents,
// 	getStudentById
// } from '../controllers/studentsController.js';

// const router = Router();

// router.get('/students', getStudents);
// router.get('/students/:studentId', getStudentById);

// export default router;

// Підсумок

// Ми винесли контролери в окремий файл і тепер маршрути виглядають більш чисто. Така організація дозволяє:

// відокремити логіку обробки запитів від опису маршрутів;
// полегшити підтримку та рефакторинг коду;
// підготувати ґрунт для подальшої роботи (наприклад, додавання нових методів чи валідації).

//!  Обробка помилок

// Уяви, що в кожному контролері ти вручну пишеш обробку помилок — це швидко перетворюється на хаос: дублювання коду, різні формати
// відповіді й зайва плутанина. Набагато зручніше мати єдине місце для обробки помилок — спеціальне middleware errorHandler яке у нас
// вже є.

// Для цього нам потрібно лише навчитися передавати помилки з контролерів у middleware. Це робиться за допомогою виклику next(error).

// Базова обробка помилки

// У контролері getStudentById метод Student.findById повертає null, якщо студент із переданим id не знайдений. Цей випадок потрібно
// обробити. Додамо параметр next у функцію та викличемо його у разі відсутності студента.

// Обов’язково після виклику next ставимо return, щоб припинити виконання коду в контролері.

// // src/controllers/studentsController.js

// // Додаємо третій параметр next до контролера
// export const getStudentById = async (req, res, next) => {
//   const { studentId } = req.params;
//   const student = await Student.findById(studentId);

//   // Код що був до цього
//   //  if (!student) {
//   //    return res.status(404).json({ message: 'Student not found' });
//   //  }

// 	// Додаємо базову обробку помилки замість res.status(404)
//   if (!student) {
//     next(new Error('Student not found'));
//     return;
//   }

//   res.status(200).json(student);
// };

// Виклик next передає управління наступному middleware у ланцюжку. Якщо забути написати return, код після next усе одно виконається —
// і це часта помилка початківців.

// Використання http-errors

// Але є нюанс: у цьому випадку ми створюємо «звичайну» помилку. Наш обробник (errorHandler) відповідає на неї кодом 500 Internal
// Server Error. Це неправильно, адже тут логічніше повернути 404 Not Found.

// Щоб робити це зручно, використаємо пакет http-errors. Він дозволяє створювати помилки з потрібним статусом і повідомленням.

// Встановлюємо пакет:

// npm install http-errors

// У контролері використовуємо функцію createHttpError:

// // src/controllers/studentsController.js
// import createHttpError from 'http-errors';

// export const getStudentById = async (req, res, next) => {
//   const { studentId } = req.params;
//   const student = await Student.findById(studentId);

//   if (!student) {
//     next(createHttpError(404, 'Student not found'));
//     return;
//   }

//   res.status(200).json(student);
// };

// Тепер замість «звичайної» помилки ми явно вказуємо код 404 і повідомлення.

// Оновлюємо errorHandler

// У middleware errorHandler також потрібно оновити код, щоб він відрізняв HTTP-помилки від інших.

// // src/middleware/errorHandler.js

// import { HttpError } from "http-errors";

// export const errorHandler = (err, req, res, next) => {
//   console.error("Error Middleware:", err);

//   // Якщо помилка створена через http-errors
//   if (err instanceof HttpError) {
//     return res.status(err.status).json({
//       message: err.message || err.name,
//     });
//   }

//   const isProd = process.env.NODE_ENV === "production";

//   // Усі інші помилки — як внутрішні
//   res.status(500).json({
//     message: isProd
//       ? "Something went wrong. Please try again later."
//       : err.message,
//   });
// };

// HttpError — це свідомо створені помилки, які ми самі генеруємо в коді (наприклад, createError(400, "Bad request"),
// createError(404, "Not Found") тощо). Такі повідомлення вважаються безпечними для користувача, оскільки вони не містять
// внутрішніх деталей застосунку чи бази даних. Тому їх можна повертати "як є" як у режимі розробки, так і в продакшені.

// А от для решти помилок ситуація інша. Їхні повідомлення можуть містити:

// частину Mongo-запиту,
// stack trace,
// назви внутрішніх змінних чи функцій.
// Таку інформацію небезпечно показувати у продакшені, тому:

// у development ми повертаємо реальний err.message, щоб було зручно дебажити,
// у production віддаємо лише загальне дружнє повідомлення, без деталей.

// Результат

// Тепер, якщо відправити запит на GET /students/:id із неіснуючим id, отримаємо у відповідь:

// статус: 404 Not Found,
// повідомлення: "Student not found".

// Таким чином ми винесли обробку помилок у єдине місце, зробили її більш правильною та зрозумілою для клієнта.
